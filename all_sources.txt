/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minimap_render.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/10 11:25:18 by javi              #+#    #+#             */
/*   Updated: 2025/11/10 17:42:29 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

/*
 * render_minimap_image - create image, call draw loop, draw ray, put to window.
 * Uses minimap->img as the local image object (same pattern you already used).
 */
void render_minimap_image(t_cub3D *cub3D, t_minimap *minimap)
{
	int img_size;
	int screen_x;
	int screen_y;
	int x;
	int y;

	img_size = MMAP_PIXEL_SIZE + minimap->tile_size;

	/* create mlx image and get buffer info */
	minimap->img.img = mlx_new_image(cub3D->mlx, img_size, img_size);
	if (!minimap->img.img)
		return;

	minimap->img.addr = mlx_get_data_addr(minimap->img.img,
			&minimap->img.bits_per_pixel, &minimap->img.line_len,
			&minimap->img.endian);

	/* draw tiles */
	y = 0;
	while (y < minimap->size)
	{
		x = 0;
		while (x < minimap->size && minimap->map[y] && minimap->map[y][x])
		{
			draw_minimap_tile(minimap, x, y);
			x++;
		}
		y++;
	}
	/* draw ray (player pointer is in cub3D->player) */
	draw_minimap_ray(minimap, cub3D->player);
	/* border */
	set_minimap_border(minimap, MMAP_COLOR_SPACE);
	/* put in bottom-left corner */
	screen_x = minimap->tile_size;
	screen_y = WIN_HEIGHT - (MMAP_PIXEL_SIZE + (minimap->tile_size * 2));
	mlx_put_image_to_window(cub3D->mlx, cub3D->win, minimap->img.img,
		screen_x, screen_y);
	mlx_destroy_image(cub3D->mlx, minimap->img.img);
}

/*
 * render_minimap - top level: prepare minimap metadata, generate char map,
 * call render_minimap_image, then free.
 */
void render_minimap(t_cub3D *cub3D)
{
	t_minimap minimap;
	int i;

	minimap.map = NULL;
	minimap.view_dist = MMAP_VIEW_DIST;
	minimap.size = (2 * minimap.view_dist) + 1;
	minimap.tile_size = MMAP_PIXEL_SIZE / (2 * minimap.view_dist);

	minimap.offset_x = get_minimap_offset(&minimap,
			cub3D->map->width, (int)cub3D->player->pos_x);
	minimap.offset_y = get_minimap_offset(&minimap,
			cub3D->map->count, (int)cub3D->player->pos_y);

	minimap.map = generate_minimap(cub3D, &minimap);
	if (!minimap.map)
	{
		printf("Error: Failed to generate minimap\n");
		return;
	}

	if (DEBUG_MINIMAP)
		debug_display_minimap(&minimap);

	render_minimap_image(cub3D, &minimap);

	/* cleanup char map */
	i = 0;
	while (minimap.map[i])
	{
		free(minimap.map[i]);
		i++;
	}
	free(minimap.map);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minimap_1.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/10 09:42:46 by javi              #+#    #+#             */
/*   Updated: 2025/11/10 17:32:00 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

/**
 * set_minimap_tile_pixels - Fill a square tile on the minimap
 */
void	set_minimap_tile_pixels(t_minimap *m, int x, int y, int color)
{
	int	i;
	int	j;

	i = 0;
	while (i < m->tile_size)
	{
		j = 0;
		while (j < m->tile_size)
		{
			my_mlx_pixel_put(&m->img, x + j, i + y, color);
			j++;
		}
		i++;
	}
}

/**
 * draw_minimap_tile - Draw one tile with appropriate color
 */
void	draw_minimap_tile(t_minimap *minimap, int x, int y)
{
	int	pixel_x;
	int	pixel_y;
	
	pixel_x = x * minimap->tile_size;
	pixel_y = y * minimap->tile_size;
	
	if (minimap->map[y][x] == 'P')
		set_minimap_tile_pixels(minimap, pixel_x, pixel_y, MMAP_COLOR_PLAYER);
	else if (minimap->map[y][x] == '1')
		set_minimap_tile_pixels(minimap, pixel_x, pixel_y, MMAP_COLOR_WALL);
	else if (minimap->map[y][x] == '0')
		set_minimap_tile_pixels(minimap, pixel_x, pixel_y, MMAP_COLOR_FLOOR);
	else if (minimap->map[y][x] == ' ')
		set_minimap_tile_pixels(minimap, pixel_x, pixel_y, MMAP_COLOR_SPACE);
}
/**
 * set_minimap_border - Draw border around minimap
 */
void	set_minimap_border(t_minimap *minimap, int color)
{
	int	size;
	int	x;
	int	y;

	size = MMAP_PIXEL_SIZE + minimap->tile_size;
	y = 0;
	while (y < size)
	{
		x = 0;
		while (x <= size)
		{
			if (x < 5 || x > size - 5 || y < 5 || y > size - 5)
				my_mlx_pixel_put(&minimap->img, x, y, color);
			x++;
		}
		y++;
	}
}
/*
 * draw_minimap_ray - draw a short line from the player's center in direction
 * of player->dir_x / dir_y. Uses integer sampling (simple Bresenham would be
 * slightly more accurate but this is lightweight and readable).
 */
void draw_minimap_ray(t_minimap *m, t_player *p)
{
	int center_x;
	int center_y;
	int i;
	int max;
	float lenf;
	float step_x;
	float step_y;

	/* center of minimap in pixels where player is drawn */
	center_x = (m->view_dist) * m->tile_size + (m->tile_size / 2);
	center_y = (m->view_dist) * m->tile_size + (m->tile_size / 2);

	/* ray length in pixels (tweakable) */
	lenf = (float)m->tile_size * 2.5f;
	max = (int)lenf;

	/* tiny float step per iteration */
	step_x = p->dir_x;
	step_y = p->dir_y;

	i = 1; /* start at 1 so we don't overwrite exact center color */
	while (i <= max)
	{
		int rx;
		int ry;

		rx = center_x + (int)(step_x * i);
		ry = center_y + (int)(step_y * i);
		my_mlx_pixel_put(&m->img, rx, ry, 0xFF0000);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 07:29:25 by javi              #+#    #+#             */
/*   Updated: 2025/11/11 23:57:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

/**
 * my_mlx_pixel_put - Fast pixel put to image buffer
 * Instead of mlx_pixel_put which updates screen immediately (slow),
 * we write directly to image memory (fast), then display once
 */
void my_mlx_pixel_put(t_cub_img *img, int x, int y, int color)
{
	char *dst;

	if (x < 0 || x >= WIN_WIDTH || y < 0 || y >= WIN_HEIGHT)
		return;
	dst = img->addr + (y * img->line_len + x * (img->bits_per_pixel / 8));
	*(unsigned int*)dst = color;
}
/**
 * get_texture_color - Sample a color from a texture at given coordinates
 * @texture: The texture image to sample from
 * @tex_x: X coordinate in texture (0-63)
 * @tex_y: Y coordinate in texture (0-63)
 * Returns: RGB color from texture
 */
int get_texture_color(t_cub_img *texture, int tex_x, int tex_y)
{
	char *pixel;
	
	if (!texture || !texture->addr)
		return (printf("Warning: trying to use missing texture\n"), 0xFF00FF); // Return magenta if texture missing
	// Clamp coordinates to texture bounds
	if (tex_x < 0) tex_x = 0;
	if (tex_x >= 64) tex_x = 63;
	if (tex_y < 0) tex_y = 0;
	if (tex_y >= 64) tex_y = 63;
	
	pixel = texture->addr + (tex_y * texture->line_len + tex_x * (texture->bits_per_pixel / 8));
	return (*(unsigned int*)pixel);
}

/**
 * get_wall_texture - Determine which texture to use based on wall hit
 * @map: Game map with loaded textures
 * @ray: Ray that hit the wall
 * @player_angle: Player's viewing angle
 * 
 * Returns: Pointer to the appropriate texture
 */
t_cub_img *get_wall_texture(t_map *map, t_ray ray)
{
	if (ray.hit_vertical)
	{
		// Vertical wall (East or West face)
		if (cos(ray.angle) > 0)
			return (&map->E_text); // Ray moving right → hit East wall
		else
			return (&map->W_text); // Ray moving left → hit West wall
	}
	else
	{
		// Horizontal wall (North or South face)
		if (sin(ray.angle) > 0)
			return (&map->S_text); // Ray moving down → hit South wall
		else
			return (&map->N_text); // Ray moving up → hit North wall
	}
}

/**
 * calculate_texture_x - Calculate X coordinate in texture
 * @ray: Ray that hit the wall
 * 
 * Returns: X coordinate in texture (0-63)
 */
int calculate_texture_x(t_ray ray)
{
	float wall_hit_pos;
	int tex_x;
	// Choose coordinate based on wall orientation
	if (ray.hit_vertical)
		wall_hit_pos = ray.wall_y;  // Vertical wall: use Y
	else
		wall_hit_pos = ray.wall_x;  // Horizontal wall: use X
	// Get fractional part (0.0 to 1.0)
	wall_hit_pos = wall_hit_pos - floor(wall_hit_pos);
	// Convert to texture coordinate (0 to 63)
	tex_x = (int)(wall_hit_pos * 64.0);
	// Ensure we're in bounds
	if (tex_x < 0)
		tex_x = 0;
	if (tex_x >= 64)
		tex_x = 63;
	
	return (tex_x);
}
/**
 * draw_textured_wall - Draw one vertical stripe with texture
 */
void draw_textured_wall(t_cub3D *cub3D, int x, int wall_height, t_ray ray)
{
	int		y;
	int		start_y;
	int		end_y;
	int		tex_x;
	int		tex_y;
	float	tex_y_step;
	float	tex_y_pos;
	t_cub_img	*texture;
	int		color;
	
	// Get which texture to use
	texture = get_wall_texture(cub3D->map, ray);	
	// Calculate wall boundaries
	start_y = (WIN_HEIGHT / 2) - (wall_height / 2);
	//printf("start_y: %d\n", start_y); //-600 from the start, something seems off.
	end_y = start_y + wall_height;
	// Calculate texture X coordinate
	tex_x = calculate_texture_x(ray);	
	// Calculate how much to increment texture Y per screen pixel
	tex_y_step = 64.0 / wall_height;
	tex_y_pos = 0;
	// Adjust for off-screen parts
	if (start_y < 0)
	{
		tex_y_pos = -start_y * tex_y_step;
		start_y = 0;
	}
	if (end_y > WIN_HEIGHT)
		end_y = WIN_HEIGHT;
	// Draw ceiling
	y = 0;
	//start_y = 100; //just for testing, as the while loop never happens at all otherwise (I wanted to see if any color was displayed, spoiler, yep.)
	while (y < start_y)
	{
		//printf("this never happens");
		my_mlx_pixel_put(&cub3D->img, x, y,
			create_rgb(cub3D->map->c_red, cub3D->map->c_green, cub3D->map->c_blue));
		y++;
	}
	// Draw textured wall
	y = start_y;
	while (y < end_y)
	{
		tex_y = (int)tex_y_pos;
		color = get_texture_color(texture, tex_x, tex_y);
		my_mlx_pixel_put(&cub3D->img, x, y, color);
		tex_y_pos += tex_y_step;
		y++;
	}
	// Draw floor
	y = end_y;
	//y = 100; //again only for testing - renders at the top as ceiling, not bottom as floor.
	while (y < WIN_HEIGHT)
	{
		//printf("hi\n");
		my_mlx_pixel_put(&cub3D->img, x, y,
			create_rgb(cub3D->map->f_red, cub3D->map->f_green, cub3D->map->f_blue));
		y++;
	}
}
/**
 * render_3d_view - Main rendering function that casts rays and draws the scene
 * @cub3D: Main game structure
 * 
 * This function:
 * 1. Casts one ray per screen column (800 rays for 800 pixel width)
 * 2. Calculates the angle for each ray relative to player's view
 * 3. Draws each wall slice based on distance - does it also change which slice of the texture?
 */
void render_3d_view(t_cub3D *cub3D) //why floats used and not double? float can have issues rounding up/down
{
	int		x;
	float	camera_x;       // X-coordinate in camera space (-1 to +1)
	float	ray_dir_x;      // Ray direction X
	float	ray_dir_y;      // Ray direction Y
	float	ray_angle;      // Calculated angle for this ray
	t_ray	ray;
	int		wall_height;
	float	perpendicular_distance;
	t_player *p;

	p = cub3D->player;
	x = 0;
	while (x < WIN_WIDTH)
	{
		// Calculate camera X (-1 = left side, +1 = right side of screen)
		camera_x = 2 * x / (float)WIN_WIDTH - 1;
		// Calculate ray direction using player direction and camera plane
		ray_dir_x = p->dir_x + p->plane_x * camera_x;
		ray_dir_y = p->dir_y + p->plane_y * camera_x;
		// Calculate angle from direction vector (for texture selection)
		ray_angle = atan2(ray_dir_y, ray_dir_x);
		ray = cast_single_ray(cub3D->player, cub3D->map, ray_angle);
			
		// Calculate angle difference from camera center
		float player_angle = atan2(p->dir_y, p->dir_x);
		float angle_diff = ray_angle - player_angle;
			
		// Normalize angle difference to [-π, π]
		while (angle_diff > PI)
			 angle_diff -= 2 * PI;
		while (angle_diff < -PI) 
			angle_diff += 2 * PI;

		// Apply fisheye correction
		perpendicular_distance = ray.distance * cos(angle_diff);
		wall_height = calculate_wall_height(perpendicular_distance);
		// Draw with texture
		draw_textured_wall(cub3D, x, wall_height, ray);
		x++;
	}
	mlx_put_image_to_window(cub3D->mlx, cub3D->win, cub3D->img.img, 0, 0); 
	render_minimap(cub3D);
}
/*
** mlx_int_do_nothing.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Tue Aug  8 12:58:24 2000 Charlie Root
** Last update Tue Sep 25 15:56:22 2001 Charlie Root
*/



int	mlx_int_do_nothing(void *param)
{
  
}
/*
** mlx_int_wait_first_expose.c for minilibx in 
** 
** Made by olivier crouzet
** Login   <ol@epita.fr>
** 
** Started on  Tue Oct 17 09:26:45 2000 olivier crouzet
** Last update Fri Feb 23 17:27:10 2001 Charlie Root
*/



#include	"mlx_int.h"



int	mlx_int_wait_first_expose(t_xvar *xvar,Window win)
{
  XEvent	ev;

  XWindowEvent(xvar->display,win,ExposureMask,&ev);
  XPutBackEvent(xvar->display,&ev);
}
/*
** mlx_loop.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Wed Aug  2 18:58:11 2000 Charlie Root
** Last update Fri Sep 30 14:47:41 2005 Olivier Crouzet
*/


#include	"mlx_int.h"

extern int	(*(mlx_int_param_event[]))();

static int	win_count(t_xvar *xvar)
{
	int			i;
	t_win_list	*win;

	i = 0;
	win = xvar->win_list;
	while (win)
	{
		win = win->next;
		++i;
	}
	return (i);
}

int			mlx_loop_end(t_xvar *xvar)
{
	xvar->end_loop = 1;
	return (1);
}

int			mlx_loop(t_xvar *xvar)
{
	XEvent		ev;
	t_win_list	*win;

	mlx_int_set_win_event_mask(xvar);
	xvar->do_flush = 0;
	while (win_count(xvar) && !xvar->end_loop)
	{
		while (!xvar->end_loop && (!xvar->loop_hook || XPending(xvar->display)))
		{
			XNextEvent(xvar->display,&ev);
			win = xvar->win_list;
			while (win && (win->window!=ev.xany.window))
				win = win->next;

			if (win && ev.type == ClientMessage && ev.xclient.message_type == xvar->wm_protocols && ev.xclient.data.l[0] == xvar->wm_delete_window && win->hooks[DestroyNotify].hook)
				win->hooks[DestroyNotify].hook(win->hooks[DestroyNotify].param);
			if (win && ev.type < MLX_MAX_EVENT && win->hooks[ev.type].hook)
				mlx_int_param_event[ev.type](xvar, &ev, win);
		}
		XSync(xvar->display, False);
		if (xvar->loop_hook)
			xvar->loop_hook(xvar->loop_param);
	}
	return (0);
}
/*
** mlx_expose_hook.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Aug  3 11:49:06 2000 Charlie Root
** Last update Fri Feb 23 17:07:42 2001 Charlie Root
*/


#include	"mlx_int.h"




int		mlx_expose_hook(t_win_list *win,int (*funct)(),void *param)
{
  win->hooks[Expose].hook = funct;
  win->hooks[Expose].param = param;
  win->hooks[Expose].mask = ExposureMask;
}
/*
** mlx_new_image.c for MiniLibX in raytraceur
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Aug 14 15:29:14 2000 Charlie Root
** Last update Wed May 25 16:46:31 2011 Olivier Crouzet
*/




#include	"mlx_int.h"

/*
** To handle X errors
*/

#define	X_ShmAttach	1

int	mlx_X_error;

int	shm_att_pb(Display *d,XErrorEvent *ev)
{
  if (ev->request_code==146 && ev->minor_code==X_ShmAttach)
    write(2,WARN_SHM_ATTACH,strlen(WARN_SHM_ATTACH));
  mlx_X_error = 1;
}


/*
**  Data malloc :  width+32 ( bitmap_pad=32 ),    *4 = *32 / 8bit
*/


void	*mlx_int_new_xshm_image(t_xvar *xvar,int width,int height,int format)
{
  t_img	*img;
  int	(*save_handler)();

  if (!(img = malloc(sizeof(*img))))
    return ((void *)0);
  bzero(img,sizeof(*img));
  img->data = 0;
  img->image = XShmCreateImage(xvar->display,xvar->visual,xvar->depth,
			       format,img->data,&(img->shm),width,height);
  if (!img->image)
    {
      free(img);
      return ((void *)0);
    }
  img->width = width;
  img->height = height;
  img->size_line = img->image->bytes_per_line;
  img->bpp = img->image->bits_per_pixel;
  img->format = format;
  img->shm.shmid = shmget(IPC_PRIVATE,(width+32)*height*4,IPC_CREAT|0777);
  if (img->shm.shmid==-1)
    {
      XDestroyImage(img->image);
      free(img);
      return ((void *)0);
    }
  img->data = img->shm.shmaddr = img->image->data = shmat(img->shm.shmid,0,0);
  if (img->data==(void *)-1)
    {
      shmctl(img->shm.shmid,IPC_RMID,0);
      XDestroyImage(img->image);
      free(img);
      return ((void *)0);
    }
  img->shm.readOnly = False;
  mlx_X_error = 0;
  save_handler = XSetErrorHandler(shm_att_pb);
  if (!XShmAttach(xvar->display,&(img->shm)) ||
      0&XSync(xvar->display,False) || mlx_X_error)
    {
      XSetErrorHandler(save_handler);
      shmdt(img->data);
      shmctl(img->shm.shmid,IPC_RMID,0);
      XDestroyImage(img->image);
      free(img);
      return ((void *)0);
    }
  XSetErrorHandler(save_handler);
  shmctl(img->shm.shmid,IPC_RMID,0);
  if (xvar->pshm_format==format)
    {
      img->pix = XShmCreatePixmap(xvar->display,xvar->root,img->shm.shmaddr,
				  &(img->shm),width,height,xvar->depth);
      img->type = MLX_TYPE_SHM_PIXMAP;
    }
  else
    {
      img->pix = XCreatePixmap(xvar->display,xvar->root,
			       width,height,xvar->depth);
      img->type = MLX_TYPE_SHM;
    }
  if (xvar->do_flush)
    XFlush(xvar->display);
  return (img);
}



void	*mlx_int_new_image(t_xvar *xvar,int width, int height,int format)
{
  t_img	*img;

  if (!(img = malloc(sizeof(*img))))
    return ((void *)0);
  if (!(img->data = malloc((width+32)*height*4)))
  {
    free(img);
    return ((void *)0);
  }
  bzero(img->data,(width+32)*height*4);
  img->image = XCreateImage(xvar->display,xvar->visual,xvar->depth,format,0,
			    img->data,width,height,32,0);
  if (!img->image)
    {
      free(img->data);
      free(img);
      return ((void *)0);
    }
  img->gc = 0;
  img->size_line = img->image->bytes_per_line;
  img->bpp = img->image->bits_per_pixel;
  img->width = width;
  img->height = height;
  img->pix = XCreatePixmap(xvar->display,xvar->root,width,height,xvar->depth);
  img->format = format;
  img->type = MLX_TYPE_XIMAGE;
  if (xvar->do_flush)
    XFlush(xvar->display);
  return (img);
}


void	*mlx_new_image(t_xvar *xvar,int width, int height)
{
  t_img	*img;

  if (xvar->use_xshm)
    if (img = mlx_int_new_xshm_image(xvar,width,height,ZPixmap))
      return (img);
  return (mlx_int_new_image(xvar,width,height,ZPixmap));
}

void	*mlx_new_image2(t_xvar *xvar,int width, int height)
{
  t_img	*img;

  if (xvar->use_xshm)
    if (img = mlx_int_new_xshm_image(xvar,width,height,XYPixmap))
      return (img);
  return (mlx_int_new_image(xvar,width,height,XYPixmap));
}
#include	"mlx_int.h"

int		mlx_get_screen_size(void *mlx_ptr, int *sizex, int *sizey)
{
	XWindowAttributes	xwAttr;
	Status				ret;
	t_xvar				*xvar;
	
	xvar = mlx_ptr;
	ret = XGetWindowAttributes(xvar->display, xvar->root, &xwAttr);
	(*sizex) = xwAttr.width;
	(*sizey) = xwAttr.height;
}
/*
** mlx_xpm.c for minilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Fri Dec  8 11:07:24 2000 Charlie Root
** Last update Thu Oct  4 16:00:22 2001 Charlie Root
*/


#include	"mlx_int.h"




void		*mlx_int_xpm_f_image(t_xvar *xvar,int *width,int *height,
				     int (*xpm_func)(),void *param)
{
  XImage	*img1;
  XImage	*img2;
  t_img		*im2;
  XpmAttributes	xpm_att;

  xpm_att.visual = xvar->visual;
  xpm_att.colormap = xvar->cmap;
  xpm_att.depth = xvar->depth;
  xpm_att.bitmap_format = ZPixmap;
  xpm_att.valuemask = XpmDepth|XpmBitmapFormat|XpmVisual|XpmColormap;
  if (xpm_func(xvar->display,param,&img1,&img2,&xpm_att))
    return ((void *)0);
  if (img2)
    XDestroyImage(img2);

  if (!(im2 = (void *)mlx_new_image(xvar,img1->width,img1->height)))
    {
      XDestroyImage(img1);
      return ((void *)0);
    }
  *width = img1->width;
  *height = img1->height;
  if (mlx_int_egal_img(im2->image,img1))
    {
      bcopy(img1->data,im2->data,img1->height*img1->bytes_per_line);
      XDestroyImage(img1);
      return (im2);
    }
  if (im2->type==MLX_TYPE_SHM_PIXMAP)
    {
      XFreePixmap(xvar->display,im2->pix);
      im2->pix = XCreatePixmap(xvar->display,xvar->root,
			       *width,*height,xvar->depth);
    }
  if (im2->type>MLX_TYPE_XIMAGE)
    {
      XShmDetach(xvar->display,&(im2->shm));
      shmdt(im2->data);
    }
  XDestroyImage(im2->image);
  im2->image = img1;
  im2->data = img1->data;
  im2->type = MLX_TYPE_XIMAGE;
  im2->size_line = img1->bytes_per_line;
  im2->bpp = img1->bits_per_pixel;
  return (im2);
}


int	mlx_int_egal_img(XImage *img1,XImage *img2)
{
  if (img1->width!=img2->width || img1->height!=img2->height ||
      img1->xoffset!=img2->xoffset || img1->format!=img2->format ||
      img1->byte_order!=img2->byte_order ||
      img1->bitmap_unit!=img2->bitmap_unit ||
      img1->bitmap_bit_order!=img2->bitmap_bit_order ||
      img1->bitmap_pad!=img2->bitmap_pad || img1->depth!=img2->depth ||
      img1->bytes_per_line!=img2->bytes_per_line ||
      img1->bits_per_pixel!=img2->bits_per_pixel ||
      img1->red_mask!=img2->red_mask || img1->green_mask!=img2->green_mask ||
      img1->blue_mask!=img2->blue_mask )
    return (0);
  return (1);
}


void	*mlx_xpm_file_to_image(t_xvar *xvar,char *filename,
			       int *width,int *height)
{
  return (mlx_int_xpm_f_image(xvar,width,height,XpmReadFileToImage,filename));
}


void	*mlx_xpm_to_image(t_xvar *xvar,char **data,int *width,int *height)
{
  return (mlx_int_xpm_f_image(xvar,width,height,XpmCreateImageFromData,(void *)data));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_destroy_display.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mg <mg@student.42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/10/03 18:56:35 by mg                #+#    #+#             */
/*   Updated: 2020/10/04 01:55:35 by mg               ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx_int.h"

int	mlx_destroy_display(t_xvar *xvar)
{
	XCloseDisplay(xvar->display);
}
/*
** mlx_destroy_window.c for MinilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Tue Mar 12 10:25:15 2002 Charlie Root
** Last update Tue May 15 16:46:08 2007 Olivier Crouzet
*/


#include	"mlx_int.h"


int	mlx_destroy_window(t_xvar *xvar,t_win_list *win)
{
  t_win_list	*w;
  t_win_list	*prev;
  t_win_list	first;

  first.next = xvar->win_list;
  prev = &first;
  w = prev->next;
  while (w)
    {
      if (w==win)
	prev->next = w->next;
      else
	prev = w;
      w = w->next;
    }
  xvar->win_list = first.next;
  XDestroyWindow(xvar->display,win->window);
  XFreeGC(xvar->display,win->gc);
  free(win);
  if (xvar->do_flush)
    XFlush(xvar->display);
}
/*
** mlx_get_data_addr.c for MiniLibX in raytraceur
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Aug 14 15:45:57 2000 Charlie Root
** Last update Thu Sep 27 19:05:25 2001 Charlie Root
*/



#include	"mlx_int.h"


char	*mlx_get_data_addr(t_img *img,int *bits_per_pixel,
			   int *size_line,int *endian)
{
  *bits_per_pixel = img->bpp;
  *size_line = img->size_line;
  *endian = img->image->byte_order;
  return (img->data);
}
/*
** This is a generated file with rgb2c.pl and rgb.txt from
** the XFree86 distribution.
*/

#include	"mlx_int.h"

struct s_col_name mlx_col_name[] =
{
 { "snow" , 0xfffafa },
 { "ghost white" , 0xf8f8ff },
 { "ghostwhite" , 0xf8f8ff },
 { "white smoke" , 0xf5f5f5 },
 { "whitesmoke" , 0xf5f5f5 },
 { "gainsboro" , 0xdcdcdc },
 { "floral white" , 0xfffaf0 },
 { "floralwhite" , 0xfffaf0 },
 { "old lace" , 0xfdf5e6 },
 { "oldlace" , 0xfdf5e6 },
 { "linen" , 0xfaf0e6 },
 { "antique white" , 0xfaebd7 },
 { "antiquewhite" , 0xfaebd7 },
 { "papaya whip" , 0xffefd5 },
 { "papayawhip" , 0xffefd5 },
 { "blanched almond" , 0xffebcd },
 { "blanchedalmond" , 0xffebcd },
 { "bisque" , 0xffe4c4 },
 { "peach puff" , 0xffdab9 },
 { "peachpuff" , 0xffdab9 },
 { "navajo white" , 0xffdead },
 { "navajowhite" , 0xffdead },
 { "moccasin" , 0xffe4b5 },
 { "cornsilk" , 0xfff8dc },
 { "ivory" , 0xfffff0 },
 { "lemon chiffon" , 0xfffacd },
 { "lemonchiffon" , 0xfffacd },
 { "seashell" , 0xfff5ee },
 { "honeydew" , 0xf0fff0 },
 { "mint cream" , 0xf5fffa },
 { "mintcream" , 0xf5fffa },
 { "azure" , 0xf0ffff },
 { "alice blue" , 0xf0f8ff },
 { "aliceblue" , 0xf0f8ff },
 { "lavender" , 0xe6e6fa },
 { "lavender blush" , 0xfff0f5 },
 { "lavenderblush" , 0xfff0f5 },
 { "misty rose" , 0xffe4e1 },
 { "mistyrose" , 0xffe4e1 },
 { "white" , 0xffffff },
 { "black" , 0x0 },
 { "dark slate" , 0x2f4f4f },
 { "darkslategray" , 0x2f4f4f },
 { "dark slate" , 0x2f4f4f },
 { "darkslategrey" , 0x2f4f4f },
 { "dim gray" , 0x696969 },
 { "dimgray" , 0x696969 },
 { "dim grey" , 0x696969 },
 { "dimgrey" , 0x696969 },
 { "slate gray" , 0x708090 },
 { "slategray" , 0x708090 },
 { "slate grey" , 0x708090 },
 { "slategrey" , 0x708090 },
 { "light slate" , 0x778899 },
 { "lightslategray" , 0x778899 },
 { "light slate" , 0x778899 },
 { "lightslategrey" , 0x778899 },
 { "gray" , 0xbebebe },
 { "grey" , 0xbebebe },
 { "light grey" , 0xd3d3d3 },
 { "lightgrey" , 0xd3d3d3 },
 { "light gray" , 0xd3d3d3 },
 { "lightgray" , 0xd3d3d3 },
 { "midnight blue" , 0x191970 },
 { "midnightblue" , 0x191970 },
 { "navy" , 0x80 },
 { "navy blue" , 0x80 },
 { "navyblue" , 0x80 },
 { "cornflower blue" , 0x6495ed },
 { "cornflowerblue" , 0x6495ed },
 { "dark slate" , 0x483d8b },
 { "darkslateblue" , 0x483d8b },
 { "slate blue" , 0x6a5acd },
 { "slateblue" , 0x6a5acd },
 { "medium slate" , 0x7b68ee },
 { "mediumslateblue" , 0x7b68ee },
 { "light slate" , 0x8470ff },
 { "lightslateblue" , 0x8470ff },
 { "medium blue" , 0xcd },
 { "mediumblue" , 0xcd },
 { "royal blue" , 0x4169e1 },
 { "royalblue" , 0x4169e1 },
 { "blue" , 0xff },
 { "dodger blue" , 0x1e90ff },
 { "dodgerblue" , 0x1e90ff },
 { "deep sky" , 0xbfff },
 { "deepskyblue" , 0xbfff },
 { "sky blue" , 0x87ceeb },
 { "skyblue" , 0x87ceeb },
 { "light sky" , 0x87cefa },
 { "lightskyblue" , 0x87cefa },
 { "steel blue" , 0x4682b4 },
 { "steelblue" , 0x4682b4 },
 { "light steel" , 0xb0c4de },
 { "lightsteelblue" , 0xb0c4de },
 { "light blue" , 0xadd8e6 },
 { "lightblue" , 0xadd8e6 },
 { "powder blue" , 0xb0e0e6 },
 { "powderblue" , 0xb0e0e6 },
 { "pale turquoise" , 0xafeeee },
 { "paleturquoise" , 0xafeeee },
 { "dark turquoise" , 0xced1 },
 { "darkturquoise" , 0xced1 },
 { "medium turquoise" , 0x48d1cc },
 { "mediumturquoise" , 0x48d1cc },
 { "turquoise" , 0x40e0d0 },
 { "cyan" , 0xffff },
 { "light cyan" , 0xe0ffff },
 { "lightcyan" , 0xe0ffff },
 { "cadet blue" , 0x5f9ea0 },
 { "cadetblue" , 0x5f9ea0 },
 { "medium aquamarine" , 0x66cdaa },
 { "mediumaquamarine" , 0x66cdaa },
 { "aquamarine" , 0x7fffd4 },
 { "dark green" , 0x6400 },
 { "darkgreen" , 0x6400 },
 { "dark olive" , 0x556b2f },
 { "darkolivegreen" , 0x556b2f },
 { "dark sea" , 0x8fbc8f },
 { "darkseagreen" , 0x8fbc8f },
 { "sea green" , 0x2e8b57 },
 { "seagreen" , 0x2e8b57 },
 { "medium sea" , 0x3cb371 },
 { "mediumseagreen" , 0x3cb371 },
 { "light sea" , 0x20b2aa },
 { "lightseagreen" , 0x20b2aa },
 { "pale green" , 0x98fb98 },
 { "palegreen" , 0x98fb98 },
 { "spring green" , 0xff7f },
 { "springgreen" , 0xff7f },
 { "lawn green" , 0x7cfc00 },
 { "lawngreen" , 0x7cfc00 },
 { "green" , 0xff00 },
 { "chartreuse" , 0x7fff00 },
 { "medium spring" , 0xfa9a },
 { "mediumspringgreen" , 0xfa9a },
 { "green yellow" , 0xadff2f },
 { "greenyellow" , 0xadff2f },
 { "lime green" , 0x32cd32 },
 { "limegreen" , 0x32cd32 },
 { "yellow green" , 0x9acd32 },
 { "yellowgreen" , 0x9acd32 },
 { "forest green" , 0x228b22 },
 { "forestgreen" , 0x228b22 },
 { "olive drab" , 0x6b8e23 },
 { "olivedrab" , 0x6b8e23 },
 { "dark khaki" , 0xbdb76b },
 { "darkkhaki" , 0xbdb76b },
 { "khaki" , 0xf0e68c },
 { "pale goldenrod" , 0xeee8aa },
 { "palegoldenrod" , 0xeee8aa },
 { "light goldenrod" , 0xfafad2 },
 { "lightgoldenrodyellow" , 0xfafad2 },
 { "light yellow" , 0xffffe0 },
 { "lightyellow" , 0xffffe0 },
 { "yellow" , 0xffff00 },
 { "gold" , 0xffd700 },
 { "light goldenrod" , 0xeedd82 },
 { "lightgoldenrod" , 0xeedd82 },
 { "goldenrod" , 0xdaa520 },
 { "dark goldenrod" , 0xb8860b },
 { "darkgoldenrod" , 0xb8860b },
 { "rosy brown" , 0xbc8f8f },
 { "rosybrown" , 0xbc8f8f },
 { "indian red" , 0xcd5c5c },
 { "indianred" , 0xcd5c5c },
 { "saddle brown" , 0x8b4513 },
 { "saddlebrown" , 0x8b4513 },
 { "sienna" , 0xa0522d },
 { "peru" , 0xcd853f },
 { "burlywood" , 0xdeb887 },
 { "beige" , 0xf5f5dc },
 { "wheat" , 0xf5deb3 },
 { "sandy brown" , 0xf4a460 },
 { "sandybrown" , 0xf4a460 },
 { "tan" , 0xd2b48c },
 { "chocolate" , 0xd2691e },
 { "firebrick" , 0xb22222 },
 { "brown" , 0xa52a2a },
 { "dark salmon" , 0xe9967a },
 { "darksalmon" , 0xe9967a },
 { "salmon" , 0xfa8072 },
 { "light salmon" , 0xffa07a },
 { "lightsalmon" , 0xffa07a },
 { "orange" , 0xffa500 },
 { "dark orange" , 0xff8c00 },
 { "darkorange" , 0xff8c00 },
 { "coral" , 0xff7f50 },
 { "light coral" , 0xf08080 },
 { "lightcoral" , 0xf08080 },
 { "tomato" , 0xff6347 },
 { "orange red" , 0xff4500 },
 { "orangered" , 0xff4500 },
 { "red" , 0xff0000 },
 { "hot pink" , 0xff69b4 },
 { "hotpink" , 0xff69b4 },
 { "deep pink" , 0xff1493 },
 { "deeppink" , 0xff1493 },
 { "pink" , 0xffc0cb },
 { "light pink" , 0xffb6c1 },
 { "lightpink" , 0xffb6c1 },
 { "pale violet" , 0xdb7093 },
 { "palevioletred" , 0xdb7093 },
 { "maroon" , 0xb03060 },
 { "medium violet" , 0xc71585 },
 { "mediumvioletred" , 0xc71585 },
 { "violet red" , 0xd02090 },
 { "violetred" , 0xd02090 },
 { "magenta" , 0xff00ff },
 { "violet" , 0xee82ee },
 { "plum" , 0xdda0dd },
 { "orchid" , 0xda70d6 },
 { "medium orchid" , 0xba55d3 },
 { "mediumorchid" , 0xba55d3 },
 { "dark orchid" , 0x9932cc },
 { "darkorchid" , 0x9932cc },
 { "dark violet" , 0x9400d3 },
 { "darkviolet" , 0x9400d3 },
 { "blue violet" , 0x8a2be2 },
 { "blueviolet" , 0x8a2be2 },
 { "purple" , 0xa020f0 },
 { "medium purple" , 0x9370db },
 { "mediumpurple" , 0x9370db },
 { "thistle" , 0xd8bfd8 },
 { "snow1" , 0xfffafa },
 { "snow2" , 0xeee9e9 },
 { "snow3" , 0xcdc9c9 },
 { "snow4" , 0x8b8989 },
 { "seashell1" , 0xfff5ee },
 { "seashell2" , 0xeee5de },
 { "seashell3" , 0xcdc5bf },
 { "seashell4" , 0x8b8682 },
 { "antiquewhite1" , 0xffefdb },
 { "antiquewhite2" , 0xeedfcc },
 { "antiquewhite3" , 0xcdc0b0 },
 { "antiquewhite4" , 0x8b8378 },
 { "bisque1" , 0xffe4c4 },
 { "bisque2" , 0xeed5b7 },
 { "bisque3" , 0xcdb79e },
 { "bisque4" , 0x8b7d6b },
 { "peachpuff1" , 0xffdab9 },
 { "peachpuff2" , 0xeecbad },
 { "peachpuff3" , 0xcdaf95 },
 { "peachpuff4" , 0x8b7765 },
 { "navajowhite1" , 0xffdead },
 { "navajowhite2" , 0xeecfa1 },
 { "navajowhite3" , 0xcdb38b },
 { "navajowhite4" , 0x8b795e },
 { "lemonchiffon1" , 0xfffacd },
 { "lemonchiffon2" , 0xeee9bf },
 { "lemonchiffon3" , 0xcdc9a5 },
 { "lemonchiffon4" , 0x8b8970 },
 { "cornsilk1" , 0xfff8dc },
 { "cornsilk2" , 0xeee8cd },
 { "cornsilk3" , 0xcdc8b1 },
 { "cornsilk4" , 0x8b8878 },
 { "ivory1" , 0xfffff0 },
 { "ivory2" , 0xeeeee0 },
 { "ivory3" , 0xcdcdc1 },
 { "ivory4" , 0x8b8b83 },
 { "honeydew1" , 0xf0fff0 },
 { "honeydew2" , 0xe0eee0 },
 { "honeydew3" , 0xc1cdc1 },
 { "honeydew4" , 0x838b83 },
 { "lavenderblush1" , 0xfff0f5 },
 { "lavenderblush2" , 0xeee0e5 },
 { "lavenderblush3" , 0xcdc1c5 },
 { "lavenderblush4" , 0x8b8386 },
 { "mistyrose1" , 0xffe4e1 },
 { "mistyrose2" , 0xeed5d2 },
 { "mistyrose3" , 0xcdb7b5 },
 { "mistyrose4" , 0x8b7d7b },
 { "azure1" , 0xf0ffff },
 { "azure2" , 0xe0eeee },
 { "azure3" , 0xc1cdcd },
 { "azure4" , 0x838b8b },
 { "slateblue1" , 0x836fff },
 { "slateblue2" , 0x7a67ee },
 { "slateblue3" , 0x6959cd },
 { "slateblue4" , 0x473c8b },
 { "royalblue1" , 0x4876ff },
 { "royalblue2" , 0x436eee },
 { "royalblue3" , 0x3a5fcd },
 { "royalblue4" , 0x27408b },
 { "blue1" , 0xff },
 { "blue2" , 0xee },
 { "blue3" , 0xcd },
 { "blue4" , 0x8b },
 { "dodgerblue1" , 0x1e90ff },
 { "dodgerblue2" , 0x1c86ee },
 { "dodgerblue3" , 0x1874cd },
 { "dodgerblue4" , 0x104e8b },
 { "steelblue1" , 0x63b8ff },
 { "steelblue2" , 0x5cacee },
 { "steelblue3" , 0x4f94cd },
 { "steelblue4" , 0x36648b },
 { "deepskyblue1" , 0xbfff },
 { "deepskyblue2" , 0xb2ee },
 { "deepskyblue3" , 0x9acd },
 { "deepskyblue4" , 0x688b },
 { "skyblue1" , 0x87ceff },
 { "skyblue2" , 0x7ec0ee },
 { "skyblue3" , 0x6ca6cd },
 { "skyblue4" , 0x4a708b },
 { "lightskyblue1" , 0xb0e2ff },
 { "lightskyblue2" , 0xa4d3ee },
 { "lightskyblue3" , 0x8db6cd },
 { "lightskyblue4" , 0x607b8b },
 { "slategray1" , 0xc6e2ff },
 { "slategray2" , 0xb9d3ee },
 { "slategray3" , 0x9fb6cd },
 { "slategray4" , 0x6c7b8b },
 { "lightsteelblue1" , 0xcae1ff },
 { "lightsteelblue2" , 0xbcd2ee },
 { "lightsteelblue3" , 0xa2b5cd },
 { "lightsteelblue4" , 0x6e7b8b },
 { "lightblue1" , 0xbfefff },
 { "lightblue2" , 0xb2dfee },
 { "lightblue3" , 0x9ac0cd },
 { "lightblue4" , 0x68838b },
 { "lightcyan1" , 0xe0ffff },
 { "lightcyan2" , 0xd1eeee },
 { "lightcyan3" , 0xb4cdcd },
 { "lightcyan4" , 0x7a8b8b },
 { "paleturquoise1" , 0xbbffff },
 { "paleturquoise2" , 0xaeeeee },
 { "paleturquoise3" , 0x96cdcd },
 { "paleturquoise4" , 0x668b8b },
 { "cadetblue1" , 0x98f5ff },
 { "cadetblue2" , 0x8ee5ee },
 { "cadetblue3" , 0x7ac5cd },
 { "cadetblue4" , 0x53868b },
 { "turquoise1" , 0xf5ff },
 { "turquoise2" , 0xe5ee },
 { "turquoise3" , 0xc5cd },
 { "turquoise4" , 0x868b },
 { "cyan1" , 0xffff },
 { "cyan2" , 0xeeee },
 { "cyan3" , 0xcdcd },
 { "cyan4" , 0x8b8b },
 { "darkslategray1" , 0x97ffff },
 { "darkslategray2" , 0x8deeee },
 { "darkslategray3" , 0x79cdcd },
 { "darkslategray4" , 0x528b8b },
 { "aquamarine1" , 0x7fffd4 },
 { "aquamarine2" , 0x76eec6 },
 { "aquamarine3" , 0x66cdaa },
 { "aquamarine4" , 0x458b74 },
 { "darkseagreen1" , 0xc1ffc1 },
 { "darkseagreen2" , 0xb4eeb4 },
 { "darkseagreen3" , 0x9bcd9b },
 { "darkseagreen4" , 0x698b69 },
 { "seagreen1" , 0x54ff9f },
 { "seagreen2" , 0x4eee94 },
 { "seagreen3" , 0x43cd80 },
 { "seagreen4" , 0x2e8b57 },
 { "palegreen1" , 0x9aff9a },
 { "palegreen2" , 0x90ee90 },
 { "palegreen3" , 0x7ccd7c },
 { "palegreen4" , 0x548b54 },
 { "springgreen1" , 0xff7f },
 { "springgreen2" , 0xee76 },
 { "springgreen3" , 0xcd66 },
 { "springgreen4" , 0x8b45 },
 { "green1" , 0xff00 },
 { "green2" , 0xee00 },
 { "green3" , 0xcd00 },
 { "green4" , 0x8b00 },
 { "chartreuse1" , 0x7fff00 },
 { "chartreuse2" , 0x76ee00 },
 { "chartreuse3" , 0x66cd00 },
 { "chartreuse4" , 0x458b00 },
 { "olivedrab1" , 0xc0ff3e },
 { "olivedrab2" , 0xb3ee3a },
 { "olivedrab3" , 0x9acd32 },
 { "olivedrab4" , 0x698b22 },
 { "darkolivegreen1" , 0xcaff70 },
 { "darkolivegreen2" , 0xbcee68 },
 { "darkolivegreen3" , 0xa2cd5a },
 { "darkolivegreen4" , 0x6e8b3d },
 { "khaki1" , 0xfff68f },
 { "khaki2" , 0xeee685 },
 { "khaki3" , 0xcdc673 },
 { "khaki4" , 0x8b864e },
 { "lightgoldenrod1" , 0xffec8b },
 { "lightgoldenrod2" , 0xeedc82 },
 { "lightgoldenrod3" , 0xcdbe70 },
 { "lightgoldenrod4" , 0x8b814c },
 { "lightyellow1" , 0xffffe0 },
 { "lightyellow2" , 0xeeeed1 },
 { "lightyellow3" , 0xcdcdb4 },
 { "lightyellow4" , 0x8b8b7a },
 { "yellow1" , 0xffff00 },
 { "yellow2" , 0xeeee00 },
 { "yellow3" , 0xcdcd00 },
 { "yellow4" , 0x8b8b00 },
 { "gold1" , 0xffd700 },
 { "gold2" , 0xeec900 },
 { "gold3" , 0xcdad00 },
 { "gold4" , 0x8b7500 },
 { "goldenrod1" , 0xffc125 },
 { "goldenrod2" , 0xeeb422 },
 { "goldenrod3" , 0xcd9b1d },
 { "goldenrod4" , 0x8b6914 },
 { "darkgoldenrod1" , 0xffb90f },
 { "darkgoldenrod2" , 0xeead0e },
 { "darkgoldenrod3" , 0xcd950c },
 { "darkgoldenrod4" , 0x8b6508 },
 { "rosybrown1" , 0xffc1c1 },
 { "rosybrown2" , 0xeeb4b4 },
 { "rosybrown3" , 0xcd9b9b },
 { "rosybrown4" , 0x8b6969 },
 { "indianred1" , 0xff6a6a },
 { "indianred2" , 0xee6363 },
 { "indianred3" , 0xcd5555 },
 { "indianred4" , 0x8b3a3a },
 { "sienna1" , 0xff8247 },
 { "sienna2" , 0xee7942 },
 { "sienna3" , 0xcd6839 },
 { "sienna4" , 0x8b4726 },
 { "burlywood1" , 0xffd39b },
 { "burlywood2" , 0xeec591 },
 { "burlywood3" , 0xcdaa7d },
 { "burlywood4" , 0x8b7355 },
 { "wheat1" , 0xffe7ba },
 { "wheat2" , 0xeed8ae },
 { "wheat3" , 0xcdba96 },
 { "wheat4" , 0x8b7e66 },
 { "tan1" , 0xffa54f },
 { "tan2" , 0xee9a49 },
 { "tan3" , 0xcd853f },
 { "tan4" , 0x8b5a2b },
 { "chocolate1" , 0xff7f24 },
 { "chocolate2" , 0xee7621 },
 { "chocolate3" , 0xcd661d },
 { "chocolate4" , 0x8b4513 },
 { "firebrick1" , 0xff3030 },
 { "firebrick2" , 0xee2c2c },
 { "firebrick3" , 0xcd2626 },
 { "firebrick4" , 0x8b1a1a },
 { "brown1" , 0xff4040 },
 { "brown2" , 0xee3b3b },
 { "brown3" , 0xcd3333 },
 { "brown4" , 0x8b2323 },
 { "salmon1" , 0xff8c69 },
 { "salmon2" , 0xee8262 },
 { "salmon3" , 0xcd7054 },
 { "salmon4" , 0x8b4c39 },
 { "lightsalmon1" , 0xffa07a },
 { "lightsalmon2" , 0xee9572 },
 { "lightsalmon3" , 0xcd8162 },
 { "lightsalmon4" , 0x8b5742 },
 { "orange1" , 0xffa500 },
 { "orange2" , 0xee9a00 },
 { "orange3" , 0xcd8500 },
 { "orange4" , 0x8b5a00 },
 { "darkorange1" , 0xff7f00 },
 { "darkorange2" , 0xee7600 },
 { "darkorange3" , 0xcd6600 },
 { "darkorange4" , 0x8b4500 },
 { "coral1" , 0xff7256 },
 { "coral2" , 0xee6a50 },
 { "coral3" , 0xcd5b45 },
 { "coral4" , 0x8b3e2f },
 { "tomato1" , 0xff6347 },
 { "tomato2" , 0xee5c42 },
 { "tomato3" , 0xcd4f39 },
 { "tomato4" , 0x8b3626 },
 { "orangered1" , 0xff4500 },
 { "orangered2" , 0xee4000 },
 { "orangered3" , 0xcd3700 },
 { "orangered4" , 0x8b2500 },
 { "red1" , 0xff0000 },
 { "red2" , 0xee0000 },
 { "red3" , 0xcd0000 },
 { "red4" , 0x8b0000 },
 { "deeppink1" , 0xff1493 },
 { "deeppink2" , 0xee1289 },
 { "deeppink3" , 0xcd1076 },
 { "deeppink4" , 0x8b0a50 },
 { "hotpink1" , 0xff6eb4 },
 { "hotpink2" , 0xee6aa7 },
 { "hotpink3" , 0xcd6090 },
 { "hotpink4" , 0x8b3a62 },
 { "pink1" , 0xffb5c5 },
 { "pink2" , 0xeea9b8 },
 { "pink3" , 0xcd919e },
 { "pink4" , 0x8b636c },
 { "lightpink1" , 0xffaeb9 },
 { "lightpink2" , 0xeea2ad },
 { "lightpink3" , 0xcd8c95 },
 { "lightpink4" , 0x8b5f65 },
 { "palevioletred1" , 0xff82ab },
 { "palevioletred2" , 0xee799f },
 { "palevioletred3" , 0xcd6889 },
 { "palevioletred4" , 0x8b475d },
 { "maroon1" , 0xff34b3 },
 { "maroon2" , 0xee30a7 },
 { "maroon3" , 0xcd2990 },
 { "maroon4" , 0x8b1c62 },
 { "violetred1" , 0xff3e96 },
 { "violetred2" , 0xee3a8c },
 { "violetred3" , 0xcd3278 },
 { "violetred4" , 0x8b2252 },
 { "magenta1" , 0xff00ff },
 { "magenta2" , 0xee00ee },
 { "magenta3" , 0xcd00cd },
 { "magenta4" , 0x8b008b },
 { "orchid1" , 0xff83fa },
 { "orchid2" , 0xee7ae9 },
 { "orchid3" , 0xcd69c9 },
 { "orchid4" , 0x8b4789 },
 { "plum1" , 0xffbbff },
 { "plum2" , 0xeeaeee },
 { "plum3" , 0xcd96cd },
 { "plum4" , 0x8b668b },
 { "mediumorchid1" , 0xe066ff },
 { "mediumorchid2" , 0xd15fee },
 { "mediumorchid3" , 0xb452cd },
 { "mediumorchid4" , 0x7a378b },
 { "darkorchid1" , 0xbf3eff },
 { "darkorchid2" , 0xb23aee },
 { "darkorchid3" , 0x9a32cd },
 { "darkorchid4" , 0x68228b },
 { "purple1" , 0x9b30ff },
 { "purple2" , 0x912cee },
 { "purple3" , 0x7d26cd },
 { "purple4" , 0x551a8b },
 { "mediumpurple1" , 0xab82ff },
 { "mediumpurple2" , 0x9f79ee },
 { "mediumpurple3" , 0x8968cd },
 { "mediumpurple4" , 0x5d478b },
 { "thistle1" , 0xffe1ff },
 { "thistle2" , 0xeed2ee },
 { "thistle3" , 0xcdb5cd },
 { "thistle4" , 0x8b7b8b },
 { "gray0" , 0x0 },
 { "grey0" , 0x0 },
 { "gray1" , 0x30303 },
 { "grey1" , 0x30303 },
 { "gray2" , 0x50505 },
 { "grey2" , 0x50505 },
 { "gray3" , 0x80808 },
 { "grey3" , 0x80808 },
 { "gray4" , 0xa0a0a },
 { "grey4" , 0xa0a0a },
 { "gray5" , 0xd0d0d },
 { "grey5" , 0xd0d0d },
 { "gray6" , 0xf0f0f },
 { "grey6" , 0xf0f0f },
 { "gray7" , 0x121212 },
 { "grey7" , 0x121212 },
 { "gray8" , 0x141414 },
 { "grey8" , 0x141414 },
 { "gray9" , 0x171717 },
 { "grey9" , 0x171717 },
 { "gray10" , 0x1a1a1a },
 { "grey10" , 0x1a1a1a },
 { "gray11" , 0x1c1c1c },
 { "grey11" , 0x1c1c1c },
 { "gray12" , 0x1f1f1f },
 { "grey12" , 0x1f1f1f },
 { "gray13" , 0x212121 },
 { "grey13" , 0x212121 },
 { "gray14" , 0x242424 },
 { "grey14" , 0x242424 },
 { "gray15" , 0x262626 },
 { "grey15" , 0x262626 },
 { "gray16" , 0x292929 },
 { "grey16" , 0x292929 },
 { "gray17" , 0x2b2b2b },
 { "grey17" , 0x2b2b2b },
 { "gray18" , 0x2e2e2e },
 { "grey18" , 0x2e2e2e },
 { "gray19" , 0x303030 },
 { "grey19" , 0x303030 },
 { "gray20" , 0x333333 },
 { "grey20" , 0x333333 },
 { "gray21" , 0x363636 },
 { "grey21" , 0x363636 },
 { "gray22" , 0x383838 },
 { "grey22" , 0x383838 },
 { "gray23" , 0x3b3b3b },
 { "grey23" , 0x3b3b3b },
 { "gray24" , 0x3d3d3d },
 { "grey24" , 0x3d3d3d },
 { "gray25" , 0x404040 },
 { "grey25" , 0x404040 },
 { "gray26" , 0x424242 },
 { "grey26" , 0x424242 },
 { "gray27" , 0x454545 },
 { "grey27" , 0x454545 },
 { "gray28" , 0x474747 },
 { "grey28" , 0x474747 },
 { "gray29" , 0x4a4a4a },
 { "grey29" , 0x4a4a4a },
 { "gray30" , 0x4d4d4d },
 { "grey30" , 0x4d4d4d },
 { "gray31" , 0x4f4f4f },
 { "grey31" , 0x4f4f4f },
 { "gray32" , 0x525252 },
 { "grey32" , 0x525252 },
 { "gray33" , 0x545454 },
 { "grey33" , 0x545454 },
 { "gray34" , 0x575757 },
 { "grey34" , 0x575757 },
 { "gray35" , 0x595959 },
 { "grey35" , 0x595959 },
 { "gray36" , 0x5c5c5c },
 { "grey36" , 0x5c5c5c },
 { "gray37" , 0x5e5e5e },
 { "grey37" , 0x5e5e5e },
 { "gray38" , 0x616161 },
 { "grey38" , 0x616161 },
 { "gray39" , 0x636363 },
 { "grey39" , 0x636363 },
 { "gray40" , 0x666666 },
 { "grey40" , 0x666666 },
 { "gray41" , 0x696969 },
 { "grey41" , 0x696969 },
 { "gray42" , 0x6b6b6b },
 { "grey42" , 0x6b6b6b },
 { "gray43" , 0x6e6e6e },
 { "grey43" , 0x6e6e6e },
 { "gray44" , 0x707070 },
 { "grey44" , 0x707070 },
 { "gray45" , 0x737373 },
 { "grey45" , 0x737373 },
 { "gray46" , 0x757575 },
 { "grey46" , 0x757575 },
 { "gray47" , 0x787878 },
 { "grey47" , 0x787878 },
 { "gray48" , 0x7a7a7a },
 { "grey48" , 0x7a7a7a },
 { "gray49" , 0x7d7d7d },
 { "grey49" , 0x7d7d7d },
 { "gray50" , 0x7f7f7f },
 { "grey50" , 0x7f7f7f },
 { "gray51" , 0x828282 },
 { "grey51" , 0x828282 },
 { "gray52" , 0x858585 },
 { "grey52" , 0x858585 },
 { "gray53" , 0x878787 },
 { "grey53" , 0x878787 },
 { "gray54" , 0x8a8a8a },
 { "grey54" , 0x8a8a8a },
 { "gray55" , 0x8c8c8c },
 { "grey55" , 0x8c8c8c },
 { "gray56" , 0x8f8f8f },
 { "grey56" , 0x8f8f8f },
 { "gray57" , 0x919191 },
 { "grey57" , 0x919191 },
 { "gray58" , 0x949494 },
 { "grey58" , 0x949494 },
 { "gray59" , 0x969696 },
 { "grey59" , 0x969696 },
 { "gray60" , 0x999999 },
 { "grey60" , 0x999999 },
 { "gray61" , 0x9c9c9c },
 { "grey61" , 0x9c9c9c },
 { "gray62" , 0x9e9e9e },
 { "grey62" , 0x9e9e9e },
 { "gray63" , 0xa1a1a1 },
 { "grey63" , 0xa1a1a1 },
 { "gray64" , 0xa3a3a3 },
 { "grey64" , 0xa3a3a3 },
 { "gray65" , 0xa6a6a6 },
 { "grey65" , 0xa6a6a6 },
 { "gray66" , 0xa8a8a8 },
 { "grey66" , 0xa8a8a8 },
 { "gray67" , 0xababab },
 { "grey67" , 0xababab },
 { "gray68" , 0xadadad },
 { "grey68" , 0xadadad },
 { "gray69" , 0xb0b0b0 },
 { "grey69" , 0xb0b0b0 },
 { "gray70" , 0xb3b3b3 },
 { "grey70" , 0xb3b3b3 },
 { "gray71" , 0xb5b5b5 },
 { "grey71" , 0xb5b5b5 },
 { "gray72" , 0xb8b8b8 },
 { "grey72" , 0xb8b8b8 },
 { "gray73" , 0xbababa },
 { "grey73" , 0xbababa },
 { "gray74" , 0xbdbdbd },
 { "grey74" , 0xbdbdbd },
 { "gray75" , 0xbfbfbf },
 { "grey75" , 0xbfbfbf },
 { "gray76" , 0xc2c2c2 },
 { "grey76" , 0xc2c2c2 },
 { "gray77" , 0xc4c4c4 },
 { "grey77" , 0xc4c4c4 },
 { "gray78" , 0xc7c7c7 },
 { "grey78" , 0xc7c7c7 },
 { "gray79" , 0xc9c9c9 },
 { "grey79" , 0xc9c9c9 },
 { "gray80" , 0xcccccc },
 { "grey80" , 0xcccccc },
 { "gray81" , 0xcfcfcf },
 { "grey81" , 0xcfcfcf },
 { "gray82" , 0xd1d1d1 },
 { "grey82" , 0xd1d1d1 },
 { "gray83" , 0xd4d4d4 },
 { "grey83" , 0xd4d4d4 },
 { "gray84" , 0xd6d6d6 },
 { "grey84" , 0xd6d6d6 },
 { "gray85" , 0xd9d9d9 },
 { "grey85" , 0xd9d9d9 },
 { "gray86" , 0xdbdbdb },
 { "grey86" , 0xdbdbdb },
 { "gray87" , 0xdedede },
 { "grey87" , 0xdedede },
 { "gray88" , 0xe0e0e0 },
 { "grey88" , 0xe0e0e0 },
 { "gray89" , 0xe3e3e3 },
 { "grey89" , 0xe3e3e3 },
 { "gray90" , 0xe5e5e5 },
 { "grey90" , 0xe5e5e5 },
 { "gray91" , 0xe8e8e8 },
 { "grey91" , 0xe8e8e8 },
 { "gray92" , 0xebebeb },
 { "grey92" , 0xebebeb },
 { "gray93" , 0xededed },
 { "grey93" , 0xededed },
 { "gray94" , 0xf0f0f0 },
 { "grey94" , 0xf0f0f0 },
 { "gray95" , 0xf2f2f2 },
 { "grey95" , 0xf2f2f2 },
 { "gray96" , 0xf5f5f5 },
 { "grey96" , 0xf5f5f5 },
 { "gray97" , 0xf7f7f7 },
 { "grey97" , 0xf7f7f7 },
 { "gray98" , 0xfafafa },
 { "grey98" , 0xfafafa },
 { "gray99" , 0xfcfcfc },
 { "grey99" , 0xfcfcfc },
 { "gray100" , 0xffffff },
 { "grey100" , 0xffffff },
 { "dark grey" , 0xa9a9a9 },
 { "darkgrey" , 0xa9a9a9 },
 { "dark gray" , 0xa9a9a9 },
 { "darkgray" , 0xa9a9a9 },
 { "dark blue" , 0x8b },
 { "darkblue" , 0x8b },
 { "dark cyan" , 0x8b8b },
 { "darkcyan" , 0x8b8b },
 { "dark magenta" , 0x8b008b },
 { "darkmagenta" , 0x8b008b },
 { "dark red" , 0x8b0000 },
 { "darkred" , 0x8b0000 },
 { "light green" , 0x90ee90 },
 { "lightgreen" , 0x90ee90 },
 { "none", -1 },
 { 0, 0 }
};
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mlx_set_font.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: amalliar <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/09/30 13:30:47 by amalliar          #+#    #+#             */
/*   Updated: 2020/09/30 17:08:36 by amalliar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx_int.h"

/*
** Allows to specify the font that will be used by mlx_string_put.
**
** Note: only fixed-width bitmap fonts are supported by Xlib, refer to xfontsel
** utility to get valid font names for this function.
*/

void	mlx_set_font(t_xvar *xvar, t_win_list *win, char *name)
{
	static Font		font = 0;

	if (font)
		XUnloadFont(xvar->display, font);
	font = XLoadFont(xvar->display, name);
	XSetFont(xvar->display, win->gc, font);
}
/*
** mlx_key_hook.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Aug  3 11:49:06 2000 Charlie Root
** Last update Fri Feb 23 17:10:09 2001 Charlie Root
*/


#include	"mlx_int.h"




int		mlx_key_hook(t_win_list *win,int (*funct)(),void *param)
{
  win->hooks[KeyRelease].hook = funct;
  win->hooks[KeyRelease].param = param;
  win->hooks[KeyRelease].mask = KeyReleaseMask;
}
/*
 ** xpm-read.c for MinilibX in 
 ** 
 ** Made by Charlie Root
 ** Login   <ol@epitech.net>
 ** 
 ** Started on  Tue Dec 11 15:25:27 2001 olivier crouzet
 ** Last update Sat Oct  1 14:56:13 2005 Olivier Crouzet
 */


#include	"mlx_int.h"

extern struct s_col_name mlx_col_name[];


#define	RETURN	{ if (colors) free(colors); if (tab) free(tab); \
		tab = (void *)0; if (colors_direct) free(colors_direct); \
		if (img) {XDestroyImage(img->image); \
				XFreePixmap(xvar->display,img->pix);free(img);} \
		return ((void *)0);}




char	*mlx_int_get_line(char *ptr,int *pos,int size)
{
	int			pos2;
	int			pos3;
	int			pos4;

	if ((pos2 = mlx_int_str_str(ptr+*pos,"\"",size-*pos))==-1)
		return ((char *)0);
	if ((pos3 = mlx_int_str_str(ptr+*pos+pos2+1,"\"",size-*pos-pos2-1))==-1)
		return ((char *)0);
	*(ptr+*pos+pos2) = 0;
	*(ptr+*pos+pos2+1+pos3) = 0;
	pos4 = *pos+pos2+1;
	*pos += pos2+pos3+2;
	return (ptr+pos4);
}


unsigned int	strlcpy_is_not_posix(char *dest, char *src, unsigned int size)
{
	unsigned	count;
	unsigned	i;

	count = 0;
	while (src[count] != '\0')
		++count;
	i = 0;
	while (src[i] != '\0' && i < (size - 1))
	{
		dest[i] = src[i];
		++i;
	}
	dest[i] = '\0';
	return (count);
}

char	*mlx_int_static_line(char **xpm_data,int *pos,int size)
{
	static char	*copy = 0;
	static int	len = 0;
	int			len2;
	char		*str;

	str = xpm_data[(*pos)++];
	if ((len2 = strlen(str))>len)
	{
			if (copy)
					free(copy);
			if (!(copy = malloc(len2+1)))
					return ((char *)0);
			len = len2;
	}
	strlcpy_is_not_posix(copy, str, len2);
	
	return (copy);
}


int	mlx_int_get_col_name(char *str,int size)
{
	int	result;

	result = 0;
	while (size--)
		result = (result<<8)+*(str++);
	
	return (result);
}

int	mlx_int_get_text_rgb(char *name, char *end)
{
	int			i;
	char		buff[64];

	if (*name == '#')
			return (strtol(name+1,0,16));
	if (end)
	{
			snprintf(buff, 64, "%s %s", name, end);
			name = buff;
	}
	i = 0;
	while (mlx_col_name[i].name)
	{
			if (!strcasecmp(mlx_col_name[i].name, name))
					return (mlx_col_name[i].color);
			i ++;
	}
	return (0);
}


int	mlx_int_xpm_set_pixel(t_img *img, char *data, int opp, int col, int x)
{
	int	dec;
	
	dec = opp;
  	while (dec--)
    {
    	if (img->image->byte_order)
			*(data+x*opp+dec) = col&0xFF;
      	else
			*(data+x*opp+opp-dec-1) = col&0xFF;
      	col >>= 8;
    }
}


void	*mlx_int_parse_xpm(t_xvar *xvar,void *info,int info_size,char *(*f)())
{
		int		pos;
		char	*line;
		char	**tab;
		char	*data;
		char	*clip_data;
		int		nc;
		int		opp;
		int		cpp;
		int		col;
		int		rgb_col;
		int		col_name;
		int		method;
		int		x;
		int		i;
		int		j;
		t_img	*img;
		t_xpm_col	*colors;
		int		*colors_direct;
		int		width;
		int		height;
		XImage	*clip_img;
		XGCValues	xgcv;
		Pixmap	clip_pix;

		colors = 0;
		colors_direct = 0;
		img = 0;
		tab = 0;
		pos = 0;
		if (!(line = f(info,&pos,info_size)) ||
						!(tab = mlx_int_str_to_wordtab(line)) || !(width = atoi(tab[0])) ||
						!(height = atoi(tab[1])) || !(nc = atoi(tab[2])) ||
						!(cpp = atoi(tab[3])) )
				RETURN;
		free(tab);
		tab = 0;

		method = 0;
		if (cpp<=2)
		{
				method = 1;
				if (!(colors_direct = malloc((cpp==2?65536:256)*sizeof(int))))
						RETURN;
		}
		else
				if (!(colors = malloc(nc*sizeof(*colors))))
						RETURN;

		clip_data = 0;

		i = nc;
		while (i--)
		{
				if (!(line = f(info,&pos,info_size)) ||
								!(tab = mlx_int_str_to_wordtab(line+cpp)) )
						RETURN;
				j = 0;
				while (tab[j] && strcmp(tab[j++],"c"));

				if (!tab[j])
						RETURN;
				rgb_col = mlx_int_get_text_rgb(tab[j], tab[j+1]);
				/*
				if ((rgb_col = mlx_int_get_text_rgb(tab[j], tab[j+1]))==-1)
				{
						if (!(clip_data = malloc(4*width*height)) ||   ok, nice size ..
										!(clip_img = XCreateImage(xvar->display, xvar->visual,
														1, XYPixmap, 0, clip_data,
														width, height, 8, (width+7)/8)) )
								RETURN;
						memset(clip_data, 0xFF, 4*width*height);
				}
				*/
				if (method)
						colors_direct[mlx_int_get_col_name(line,cpp)] = rgb_col;
								// rgb_col>=0?mlx_get_color_value(xvar, rgb_col):rgb_col;
				else
				{
						colors[i].name = mlx_int_get_col_name(line,cpp);
						colors[i].col = rgb_col; //rgb_col>=0?mlx_get_color_value(xvar,rgb_col):rgb_col;
				}
				free(tab);
				tab = (void *)0;
		}

		if (!(img = mlx_new_image(xvar,width,height)))
				RETURN;
		opp = img->bpp/8;


		i = height;
		data = img->data;
		while (i--)
		{
				if (!(line = f(info,&pos,info_size)))
						RETURN;
				x = 0;
				while (x<width)
				{
						col = 0;
						col_name = mlx_int_get_col_name(line+cpp*x,cpp);
						if (method)
								col = colors_direct[col_name];
						else
						{
								j = nc;
								while (j--)
										if (colors[j].name==col_name)
										{
												col = colors[j].col;
												j = 0;
										}
						}
						/*
						if (col==-1)
								XPutPixel(clip_img, x, height-1-i, 0);
						else
								mlx_int_xpm_set_pixel(img, data, opp, col, x);
						x ++;
						*/
						if (col==-1)
							col = 0xFF000000;
						mlx_int_xpm_set_pixel(img, data, opp, col, x);
						++x;
				}
				data += img->size_line;
		}
		/*
		if (clip_data)
		{
				if (!(clip_pix = XCreatePixmap(xvar->display, xvar->root,
												width, height, 1)) )
						RETURN;
				img->gc = XCreateGC(xvar->display, clip_pix, 0, &xgcv);
				XPutImage(xvar->display, clip_pix, img->gc, clip_img,
								0, 0, 0, 0, width, height);
				XFreeGC(xvar->display, img->gc);
				xgcv.clip_mask = clip_pix;
				xgcv.function = GXcopy;
				xgcv.plane_mask = AllPlanes;
				img->gc = XCreateGC(xvar->display, xvar->root, GCClipMask|GCFunction|
								GCPlaneMask, &xgcv);
				XSync(xvar->display, False);
				XDestroyImage(clip_img);
		}
		*/
		if (colors)
				free(colors);
		if (colors_direct)
				free(colors_direct);
		return (img);
}


int	mlx_int_file_get_rid_comment(char *ptr, int size)
{
		int	com_begin;
		int	com_end;

		while ((com_begin = mlx_int_str_str_cote(ptr,"/*",size))!=-1)
		{
				com_end = mlx_int_str_str(ptr+com_begin+2,"*/",size-com_begin-2);
				memset(ptr+com_begin,' ',com_end+4);
		}
		while ((com_begin = mlx_int_str_str_cote(ptr,"//",size))!=-1)
		{
				com_end = mlx_int_str_str(ptr+com_begin+2,"\n",size-com_begin-2);
				memset(ptr+com_begin,' ',com_end+3);
		}
}


void	*mlx_xpm_file_to_image(t_xvar *xvar,char *file,int *width,int *height)
{
		int	fd;
		int	size;
		char	*ptr;
		t_img	*img;

		fd = -1;
		if ((fd = open(file,O_RDONLY))==-1 || (size = lseek(fd,0,SEEK_END))==-1 ||
						(ptr = mmap(0,size,PROT_WRITE|PROT_READ,MAP_PRIVATE,fd,0))==
						(void *)MAP_FAILED)
		{
				if (fd>=0)
						close(fd);
				return ((void *)0);
		}
		mlx_int_file_get_rid_comment(ptr, size);
		if (img = mlx_int_parse_xpm(xvar,ptr,size,mlx_int_get_line))
		{
				*width = img->width;
				*height = img->height;
		}
		munmap(ptr,size);
		close(fd);
		return (img);
}

void	*mlx_xpm_to_image(t_xvar *xvar,char **xpm_data,int *width,int *height)
{
		t_img	*img;

		if (img = mlx_int_parse_xpm(xvar,xpm_data,0,mlx_int_static_line))
		{
				*width = img->width;
				*height = img->height;
		}
		return (img);
}

#include	"mlx.h"
#include	"mlx_int.h"

#define	WIN1_SX		242
#define	WIN1_SY		242
#define	IM1_SX		42
#define	IM1_SY		42
#define	IM3_SX		242
#define	IM3_SY		242

void	*mlx;
void	*win1;
void    *win2;
void    *win3;
void    *im1;
void	*im2;
void	*im3;
void	*im4;
int	bpp1;
int	bpp2;
int	bpp3;
int	bpp4;
int	sl1;
int	sl2;
int	sl3;
int	sl4;
int	endian1;
int	endian2;
int	endian3;
int	endian4;
char	*data1;
char	*data2;
char	*data3;
char	*data4;
int	xpm1_x;
int	xpm1_y;

int	local_endian;

int	color_map_1(void *win,int w,int h);
int	color_map_2(unsigned char *data,int bpp,int sl,int w,int h,int endian, int type);

int	expose_win1(void *p)
{
  mlx_put_image_to_window(mlx,win1,im3,0,0);
}

int	expose_win2(void *p)
{
  mlx_put_image_to_window(mlx,win2,im4,0,0);
  mlx_put_image_to_window(mlx,win2,im2,0,0);
}

int	key_win1(int key,void *p)
{
  printf("Key in Win1 : %d\n",key);
  if (key==0xFF1B)
    exit(0);
}

int	key_win2(int key,void *p)
{
  printf("Key in Win2 : %d\n",key);
  if (key==0xFF1B)
    exit(0);
}

int	key_win3(int key,void *p)
{
  printf("Key in Win3 : %d\n",key);
  if (key==0xFF1B)
    mlx_destroy_window(mlx,win3);
}

int	mouse_win1(int button,int x,int y, void *p)
{
  printf("Mouse in Win1, button %d at %dx%d.\n",button,x,y);
}

int	mouse_win2(int button,int x,int y, void *p)
{
  printf("Mouse in Win2, button %d at %dx%d.\n",button,x,y);
}

int	mouse_win3(int x,int y, void *p)
{
  printf("Mouse moving in Win3, at %dx%d.\n",x,y);
}


int	main()
{
  int	a;

  printf("MinilibX Test Program\n");
  a = 0x11223344;
  if (((unsigned char *)&a)[0] == 0x11)
    local_endian = 1;
  else
    local_endian = 0;
  printf(" => Local Endian : %d\n",local_endian);

  printf(" => Connection ...");
  if (!(mlx = mlx_init()))
    {
      printf(" !! KO !!\n");
      exit(1);
    }
  printf("OK (use_xshm %d pshm_format %d)\n",((t_xvar *)mlx)->use_xshm,((t_xvar *)mlx)->pshm_format);

  printf(" => Window1 %dx%d \"Title 1\" ...",WIN1_SX,WIN1_SY);
  if (!(win1 = mlx_new_window(mlx,WIN1_SX,WIN1_SY,"Title1")))
    {
      printf(" !! KO !!\n");
      exit(1);
    }
  printf("OK\n");

  printf(" => Colormap sans event ...");
  color_map_1(win1,WIN1_SX,WIN1_SY);
  printf("OK\n");
  sleep(2);

  printf(" => Clear Window ...");
  mlx_clear_window(mlx,win1);
  printf("OK\n");
  sleep(2);

  printf(" => Image1 ZPixmap %dx%d ...",IM1_SX,IM1_SY);
  if (!(im1 = mlx_new_image(mlx,IM1_SX,IM1_SY)))
    {
      printf(" !! KO !!\n");
      exit(1);
    }
  data1 = mlx_get_data_addr(im1,&bpp1,&sl1,&endian1);
  printf("OK (bpp1: %d, sizeline1: %d endian: %d type: %d)\n",bpp1,sl1,endian1,
	 ((t_img *)im1)->type);

  printf(" => Fill Image1 ...");
  color_map_2(data1,bpp1,sl1,IM1_SX,IM1_SY,endian1, 1);
  printf("OK (pixmap : %d)\n",(int)((t_img *)im1)->pix);

  printf(" => Put Image1 ...");
  mlx_put_image_to_window(mlx,win1,im1,20,20);
  printf("OK\n");
  sleep(2);

  printf(" => Destroy Image1 ... ");
  mlx_destroy_image(mlx, im1);
  printf("OK\n");
  sleep(2);

  printf(" => Image3 ZPixmap %dx%d ...",IM3_SX,IM3_SY);
  if (!(im3 = mlx_new_image(mlx,IM3_SX,IM3_SY)))
    {
      printf(" !! KO !!\n");
      exit(1);
    }
  data3 = mlx_get_data_addr(im3,&bpp3,&sl3,&endian3);
  printf("OK (bpp3 %d, sizeline3 %d endian3 %d type %d)\n",bpp3,sl3,endian3,
	 ((t_img *)im3)->type);

  printf(" => Fill Image3 ...");
  color_map_2(data3,bpp3,sl3,IM3_SX,IM3_SY,endian3, 1);
  printf("OK (pixmap : %d)\n",(int)((t_img *)im3)->pix);

  printf(" => Put Image3 ...");
  mlx_put_image_to_window(mlx,win1,im3,20,20);
  printf("OK\n");
  sleep(2);

  printf(" => String ...");
  mlx_string_put(mlx,win1,5,WIN1_SY/2,0xFF99FF,"String output");
  mlx_string_put(mlx,win1,15,WIN1_SY/2+20,0x00FFFF,"MinilibX test");
  printf("OK\n");
  sleep(2);

  printf(" => Xpm from file ...");
  if (!(im2 = mlx_xpm_file_to_image(mlx,"open.xpm",&xpm1_x,&xpm1_y)))
    {
      printf(" !! KO !!\n");
      exit(1);
    }
  data2 = mlx_get_data_addr(im2,&bpp2,&sl2,&endian2);
  printf("OK (xpm %dx%d)(img bpp2: %d, sizeline2: %d endian: %d type: %d)\n",
	 xpm1_x,xpm1_y,bpp2,sl2,endian2,((t_img *)im2)->type);
  sleep(2);

  printf(" => Put xpm ...");
  mlx_put_image_to_window(mlx,win1,im2,0,0);
  mlx_put_image_to_window(mlx,win1,im2,100,100);
  printf("OK\n");
  sleep(2);

  printf(" => 2nd window,");
  win2 = mlx_new_window(mlx,WIN1_SX,WIN1_SY,"Title2");
  if (!(im4 = mlx_new_image(mlx,IM3_SX, IM3_SY)))
    {
      printf(" !! KO !!\n");
      exit(1);
    }
  data4 = mlx_get_data_addr(im4,&bpp4,&sl4,&endian4);
  color_map_2(data4,bpp4,sl4,IM3_SX,IM3_SY,endian4, 2);

  printf(" 3rd window, Installing hooks ...");
  win3 = mlx_new_window(mlx,WIN1_SX,WIN1_SY,"Title3");
  mlx_expose_hook(win1,expose_win1,0);
  mlx_mouse_hook(win1,mouse_win1,0);
  mlx_key_hook(win1,key_win1,0);
  mlx_expose_hook(win2,expose_win2,0);
  mlx_mouse_hook(win2,mouse_win2,0);
  mlx_key_hook(win2,key_win2,0);
  mlx_key_hook(win3,key_win3,0);

  mlx_hook(win3, MotionNotify, PointerMotionMask, mouse_win3, 0);

  printf("OK\nNow in Loop. Just play. Esc in 3 to destroy, 1&2 to quit.\n");
  
  mlx_loop(mlx);
}


int	color_map_1(void *win,int w,int h)
{
  int	x;
  int	y;
  int	color;

  x = w;
  while (x--)
    {
      y = h;
      while (y--)
        {
          color = (x*255)/w+((((w-x)*255)/w)<<16)+(((y*255)/h)<<8);
	  mlx_pixel_put(mlx,win,x,y,color);
        }
    }
}


int	color_map_2(unsigned char *data,int bpp,int sl,int w,int h,int endian, int type)
{
  int	x;
  int	y;
  int	opp;
  int	dec;
  int	color;
  int	color2;
  unsigned char *ptr;

  opp = bpp/8;
  printf("(opp : %d) ",opp);
  y = h;
  while (y--)
    {
      ptr = data+y*sl;
      x = w;
      while (x--)
        {
	  if (type==2)
	    color = (y*255)/w+((((w-x)*255)/w)<<16)
	      +(((y*255)/h)<<8);
	  else
	    color = (x*255)/w+((((w-x)*255)/w)<<16)+(((y*255)/h)<<8);
          color2 = mlx_get_color_value(mlx,color);
	  dec = opp;
	  while (dec--)
	    if (endian==local_endian)
	      {
		if (endian)
		  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[4-opp+dec];
		else
		  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[dec];
	      }
	    else
	      {
		if (endian)
		  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[opp-1-dec];
		else
		  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[3-dec];
	      }
        }
    }

}



#include "mlx.h"


void *mlx;
void *win1;
void *win2;



int gere_mouse(int x,int y,int button,void*toto)
{
  printf("Mouse event - new win\n");
  mlx_destroy_window(mlx,win1);
  win1 = mlx_new_window(mlx,random()%500,random()%500,"new win");
  mlx_mouse_hook(win1,gere_mouse,0);
}


int main()
{
  srandom(time(0));
  mlx = mlx_init();
  win1 = mlx_new_window(mlx,300,300,"win1");
  win2 = mlx_new_window(mlx,600,600,"win2");
  mlx_mouse_hook(win1,gere_mouse,0);
  mlx_mouse_hook(win2,gere_mouse,0);
  mlx_loop(mlx);
}
#include "mlx_int.h"

int		mlx_mouse_move(t_xvar *xvar, t_win_list *win, int x, int y)
{
	XWarpPointer(xvar->display, None, win->window, 0, 0, 0, 0, x, y);
	return (0);
}

int		mlx_mouse_hide(t_xvar *xvar, t_win_list *win)
{
	static char data[1] = {0};
	Cursor cursor;
	Pixmap blank;
	XColor dummy;

	blank = XCreateBitmapFromData(xvar->display, win->window, data, 1, 1);
	cursor = XCreatePixmapCursor(xvar->display, blank, blank, &dummy, &dummy, 0, 0);
	XDefineCursor(xvar->display, win->window, cursor);
	XFreePixmap(xvar->display, blank);
	XFreeCursor(xvar->display, cursor);
}

int		mlx_mouse_show(t_xvar *xvar, t_win_list *win)
{
	XUndefineCursor(xvar->display, win->window);
}

/*
** Queries the position of the mouse pointer relative to the origin of the
** specified window and saves it to the provided location.
**
** If the pointer is not on the same screen as the specified window, both
** win_x_return and win_y_return are set to zero and the function returns 0.
*/

int		mlx_mouse_get_pos(t_xvar *xvar, t_win_list *win, \
			int *win_x_return, int *win_y_return)
{
	Window		root_return;
	Window		child_return;
	int			root_x_return;
	int			root_y_return;
	unsigned	mask_return;

	return (XQueryPointer(xvar->display, win->window, \
		&root_return, &child_return, &root_x_return, &root_y_return, \
		win_x_return, win_y_return, &mask_return));
}
/*
** mlx_int_str_to_wordtab.c for MinilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Wed Sep 13 11:36:09 2000 Charlie Root
** Last update Fri Dec 14 11:02:09 2001 Charlie Root
*/


#include	"mlx_int.h"


int	mlx_int_str_str(char *str,char *find,int len)
{
  int	len_f;
  int	pos;
  char	*s;
  char	*f;

  len_f = strlen(find);
  if (len_f>len)
    return (-1);
  pos = 0;
  while (*(str+len_f-1))
    {
      s = str;
      f = find;
      while (*(f++) == *(s++))
        if (!*f)
          return (pos);
      str ++;
      pos ++;
    }
  return (-1);
}



int	mlx_int_str_str_cote(char *str,char *find,int len)
{
  int	len_f;
  int	pos;
  char	*s;
  char	*f;
  int	cote;

  len_f = strlen(find);
  if (len_f>len)
    return (-1);
  cote = 0;
  pos = 0;
  while (*(str+len_f-1))
    {
      if (*str=='"')
	cote = 1-cote;
      if (!cote)
	{
	  s = str;
	  f = find;
	  while (*(f++) == *(s++))
	    if (!*f)
	      return (pos);
	}
      str ++;
      pos ++;
    }
  return (-1);
}


char	**mlx_int_str_to_wordtab(char *str)
{
  char	**tab;
  int	pos;
  int	nb_word;
  int	len;

  len = strlen(str);
  nb_word = 0;
  pos = 0;
  while (pos<len)
  {
    while (*(str+pos)==' ' || *(str+pos)=='\t')
      pos ++;
    if (*(str+pos))
      nb_word ++;
    while (*(str+pos) && *(str+pos)!=' ' && *(str+pos)!='\t')
      pos ++;
  }
  if (!(tab = malloc((1+nb_word)*sizeof(*tab))))
    return ((char **)0);
  nb_word = 0;
  pos = 0;
  while (pos<len)
    {
      while (*(str+pos)==' ' || *(str+pos)=='\t')
	{
	  *(str+pos) = 0;
	  pos ++;
	}
      if (*(str+pos))
	{
	  tab[nb_word] = str+pos;
	  nb_word ++;
	}
      while (*(str+pos) && *(str+pos)!=' ' && *(str+pos)!='\t')
	pos ++;
    }
  tab[nb_word] = 0;
  return (tab);
}
/*
** mlx_mouse_hook.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Aug  3 11:49:06 2000 Charlie Root
** Last update Fri Feb 23 17:11:05 2001 Charlie Root
*/


#include	"mlx_int.h"




int		mlx_mouse_hook(t_win_list *win,int (*funct)(),void *param)
{
  win->hooks[ButtonPress].hook = funct;
  win->hooks[ButtonPress].param = param;
  win->hooks[ButtonPress].mask = ButtonPressMask;
}
/*
** mlx.h for MinilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Jul 31 16:37:50 2000 Charlie Root
** Last update Tue May 15 16:23:28 2007 Olivier Crouzet
*/

/*
**   MinilibX -  Please report bugs
*/


/*
** FR msg - FR msg - FR msg
**
** La MinilibX utilise 2 librairies supplementaires qu'il
**      est necessaire de rajouter a la compilation :
**   -lmlx -lXext -lX11
**
** La MinilibX permet le chargement des images de type Xpm.
** Notez que cette implementation est incomplete.
** Merci de communiquer tout probleme de chargement d'image
** de ce type.
*/


#ifndef MLX_H

#define	MLX_H


void	*mlx_init();
/*
**  needed before everything else.
**  return (void *)0 if failed
*/


/*
** Basic actions
*/

void	*mlx_new_window(void *mlx_ptr, int size_x, int size_y, char *title);
/*
**  return void *0 if failed
*/
int	mlx_clear_window(void *mlx_ptr, void *win_ptr);
int	mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color);
/*
**  origin for x & y is top left corner of the window
**  y down is positive
**  color is 0x00RRGGBB
*/


/*
** Image stuff
*/

void	*mlx_new_image(void *mlx_ptr,int width,int height);
/*
**  return void *0 if failed
**  obsolete : image2 data is stored using bit planes
**  void	*mlx_new_image2(void *mlx_ptr,int width,int height);
*/
char	*mlx_get_data_addr(void *img_ptr, int *bits_per_pixel,
			   int *size_line, int *endian);
/*
**  endian : 0 = sever X is little endian, 1 = big endian
**  for mlx_new_image2, 2nd arg of mlx_get_data_addr is number_of_planes
*/
int	mlx_put_image_to_window(void *mlx_ptr, void *win_ptr, void *img_ptr,
				int x, int y);
int	mlx_get_color_value(void *mlx_ptr, int color);


/*
** dealing with Events
*/

int	mlx_mouse_hook (void *win_ptr, int (*funct_ptr)(), void *param);
int	mlx_key_hook (void *win_ptr, int (*funct_ptr)(), void *param);
int	mlx_expose_hook (void *win_ptr, int (*funct_ptr)(), void *param);

int	mlx_loop_hook (void *mlx_ptr, int (*funct_ptr)(), void *param);
int	mlx_loop (void *mlx_ptr);
int mlx_loop_end (void *mlx_ptr);

/*
**  hook funct are called as follow :
**
**   expose_hook(void *param);
**   key_hook(int keycode, void *param);
**   mouse_hook(int button, int x,int y, void *param);
**   loop_hook(void *param);
**
*/


/*
**  Usually asked...
*/

int	mlx_string_put(void *mlx_ptr, void *win_ptr, int x, int y, int color,
		       char *string);
void	mlx_set_font(void *mlx_ptr, void *win_ptr, char *name);
void	*mlx_xpm_to_image(void *mlx_ptr, char **xpm_data,
			  int *width, int *height);
void	*mlx_xpm_file_to_image(void *mlx_ptr, char *filename,
			       int *width, int *height);
int	mlx_destroy_window(void *mlx_ptr, void *win_ptr);

int	mlx_destroy_image(void *mlx_ptr, void *img_ptr);

int	mlx_destroy_display(void *mlx_ptr);

/*
**  generic hook system for all events, and minilibX functions that
**    can be hooked. Some macro and defines from X11/X.h are needed here.
*/

int	mlx_hook(void *win_ptr, int x_event, int x_mask,
                 int (*funct)(), void *param);

int	mlx_do_key_autorepeatoff(void *mlx_ptr);
int	mlx_do_key_autorepeaton(void *mlx_ptr);
int	mlx_do_sync(void *mlx_ptr);

int	mlx_mouse_get_pos(void *mlx_ptr, void *win_ptr, int *x, int *y);
int	mlx_mouse_move(void *mlx_ptr, void *win_ptr, int x, int y);
int	mlx_mouse_hide(void *mlx_ptr, void *win_ptr);
int	mlx_mouse_show(void *mlx_ptr, void *win_ptr);

int	mlx_get_screen_size(void *mlx_ptr, int *sizex, int *sizey);

#endif /* MLX_H */
/*
** mlx_put_image_to_window.c for MiniLibX in raytraceur
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Aug 14 15:55:49 2000 Charlie Root
** Last update Sun Oct  2 09:53:00 2005 Olivier Crouzet
*/



#include	"mlx_int.h"


int	mlx_put_image_to_window(t_xvar *xvar,t_win_list *win,t_img *img,
				int x,int y)
{
  GC	gc;

  gc = win->gc;
  if (img->gc)
    {
      gc = img->gc;
      XSetClipOrigin(xvar->display, gc, x, y);
    }
  if (img->type==MLX_TYPE_SHM)
    XShmPutImage(xvar->display,img->pix, win->gc, img->image,0,0,0,0,
		 img->width,img->height,False);
  if (img->type==MLX_TYPE_XIMAGE)
    XPutImage(xvar->display,img->pix, win->gc, img->image,0,0,0,0,
	      img->width,img->height);
  XCopyArea(xvar->display,img->pix,win->window, gc,
	    0,0,img->width,img->height,x,y);
  if (xvar->do_flush)
    XFlush(xvar->display);
}
/*
** mlx_int_set_win_event_mask.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Aug  3 11:49:06 2000 Charlie Root
** Last update Fri Feb 23 17:07:42 2001 Charlie Root
*/


#include	"mlx_int.h"




int	mlx_int_set_win_event_mask(t_xvar *xvar)
{
  t_win_list	*win;
  int		mask;
  int		i;
  XSetWindowAttributes	xwa;

  win = xvar->win_list;
  while (win)
    {
      xwa.event_mask = 0;
      i = MLX_MAX_EVENT;
      while (i--)
	xwa.event_mask |= win->hooks[i].mask;
      XChangeWindowAttributes(xvar->display, win->window, CWEventMask, &xwa);
      win = win->next;
    }
}
/*
** mlx_init.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Jul 31 16:52:42 2000 Charlie Root
** Last update Fri Jan 28 17:05:09 2005 Olivier Crouzet
*/


#include	"mlx_int.h"



void	*mlx_init()
{
	t_xvar	*xvar;
	
	if (!(xvar = malloc(sizeof(*xvar))))
		return ((void*)0);
	if ((xvar->display = XOpenDisplay("")) == 0)
	{
		free(xvar);
		return ((void*)0);
	}
	xvar->screen = DefaultScreen(xvar->display);
	xvar->root = DefaultRootWindow(xvar->display);
	xvar->cmap = DefaultColormap(xvar->display,xvar->screen);
	xvar->depth = DefaultDepth(xvar->display,xvar->screen);
	if (mlx_int_get_visual(xvar)==-1)
	{
		printf(ERR_NO_TRUECOLOR);
		exit(1);
	}
	xvar->win_list = 0;
	xvar->loop_hook = 0;
	xvar->loop_param = (void *)0;
	xvar->do_flush = 1;
	xvar->wm_delete_window = XInternAtom (xvar->display, "WM_DELETE_WINDOW", False);
	xvar->wm_protocols = XInternAtom (xvar->display, "WM_PROTOCOLS", False);
	mlx_int_deal_shm(xvar);
	if (xvar->private_cmap)
		xvar->cmap = XCreateColormap(xvar->display,xvar->root,
				 xvar->visual,AllocNone);
	mlx_int_rgb_conversion(xvar);
	xvar->end_loop = 0;
	return (xvar);
}


/*
** pshm_format of -1 :	Not XYBitmap|XYPixmap|ZPixmap
** alpha libX need a check of the DISPLAY env var, or shm is allowed
** in remote Xserver connections.
*/

int		mlx_int_deal_shm(t_xvar *xvar)
{
	int		use_pshm;
	int		bidon;
	char	*dpy;
	char	buff[33];

	xvar->use_xshm = XShmQueryVersion(xvar->display,&bidon,&bidon,&(use_pshm));
	if (xvar->use_xshm && use_pshm)
		xvar->pshm_format = XShmPixmapFormat(xvar->display);
	else
		xvar->pshm_format = -1;
	gethostname(buff,32);
	dpy = getenv(ENV_DISPLAY);
	if (dpy && strlen(dpy) && *dpy!=':' && strncmp(dpy,buff,strlen(buff)) &&
			strncmp(dpy,LOCALHOST,strlen(LOCALHOST)) )
	{
		xvar->pshm_format = -1;
		xvar->use_xshm = 0;
	}
}

/*
** TrueColor Visual is needed to have *_mask correctly set
*/

int		mlx_int_rgb_conversion(t_xvar *xvar)
{
	bzero(xvar->decrgb,sizeof(int)*6);
	while (!(xvar->visual->red_mask&1))
		{ xvar->visual->red_mask >>= 1; xvar->decrgb[0] ++; }
	while (xvar->visual->red_mask&1)
		{ xvar->visual->red_mask >>= 1; xvar->decrgb[1] ++; }
	while (!(xvar->visual->green_mask&1))
		{ xvar->visual->green_mask >>= 1; xvar->decrgb[2] ++; }
	while (xvar->visual->green_mask&1)
		{ xvar->visual->green_mask >>= 1; xvar->decrgb[3] ++; }
	while (!(xvar->visual->blue_mask&1))
		{ xvar->visual->blue_mask >>= 1; xvar->decrgb[4] ++; }
	while (xvar->visual->blue_mask&1)
		{ xvar->visual->blue_mask >>= 1; xvar->decrgb[5] ++; }
}
/*
** mlx_get_color_value.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Jul 31 19:01:33 2000 Charlie Root
** Last update Thu Oct  4 15:04:13 2001 Charlie Root
*/


#include	"mlx_int.h"


int             mlx_get_color_value(t_xvar *xvar,int color)
{
  return(mlx_int_get_good_color(xvar,color));
}

int		mlx_int_get_good_color(t_xvar *xvar,int color)
{
  XColor	xc;

  if (xvar->depth>=24)
    return (color);
  xc.red = (color>>8)&0xFF00;
  xc.green = color&0xFF00;
  xc.blue = (color<<8)&0xFF00;
  xc.pixel = ((xc.red>>(16-xvar->decrgb[1]))<<xvar->decrgb[0])+
    ((xc.green>>(16-xvar->decrgb[3]))<<xvar->decrgb[2])+
    ((xc.blue>>(16-xvar->decrgb[5]))<<xvar->decrgb[4]);
  return (xc.pixel);
}
/*
** mlx_int_get_visual.c for MinilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Wed Oct  3 17:01:51 2001 Charlie Root
** Last update Thu Oct  4 15:00:45 2001 Charlie Root
*/



#include	"mlx_int.h"


/*
** We need a private colormap for non-default Visual.
*/


int		mlx_int_get_visual(t_xvar *xvar)
{
  XVisualInfo	*vi;
  XVisualInfo	template;
  int		nb_item;

  xvar->private_cmap = 0;
  xvar->visual = DefaultVisual(xvar->display,xvar->screen);
  if (xvar->visual->class == TrueColor)
    return (0);
  template.class = TrueColor;
  template.depth = xvar->depth;
  if (!(vi = XGetVisualInfo(xvar->display,VisualDepthMask|VisualClassMask,
			    &template,&nb_item)) )
    return (-1);
  xvar->visual = vi->visual;
  xvar->private_cmap = 1;
  return (0);
}
/*
** mlx_flush_event.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Wed Aug  2 18:58:11 2000 Charlie Root
** Last update Fri Feb 23 17:08:48 2001 Charlie Root
*/


#include	"mlx_int.h"




int	mlx_flush_event(t_xvar *xvar)
{
  XEvent	ev;

  while (XPending(xvar->display))
  {
     XNextEvent(xvar->display,&ev);
  }
}
/*
 ** mlx_string_put.c for MiniLibX in 
 ** 
 ** Made by Charlie Root
 ** Login   <ol@epitech.net>
 ** 
 ** Started on  Mon Jul 31 19:01:33 2000 Charlie Root
** Last update Tue Sep 25 17:11:47 2001 Charlie Root
 */


#include	"mlx_int.h"



int		mlx_string_put(t_xvar *xvar,t_win_list *win,
			       int x,int y,int color,char *string)
{
   XGCValues	xgcv;
   
   xgcv.foreground = mlx_int_get_good_color(xvar,color);
   XChangeGC(xvar->display,win->gc,GCForeground,&xgcv);
   XDrawString(xvar->display,win->window,win->gc,x,y,string,strlen(string));
   if (xvar->do_flush)
     XFlush(xvar->display);
}
/*
** mlx_int_anti_resize_win.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Tue Aug  8 14:31:05 2000 Charlie Root
** Last update Tue Sep 25 15:56:58 2001 Charlie Root
*/

#include	"mlx_int.h"


int	mlx_int_anti_resize_win(t_xvar *xvar,Window win,int w,int h)
{
  XSizeHints    hints;
  long		toto;
  
  XGetWMNormalHints(xvar->display,win,&hints,&toto);
  hints.width = w;
  hints.height = h;
  hints.min_width = w;
  hints.min_height = h;
  hints.max_width = w;
  hints.max_height = h;
  hints.flags = PPosition | PSize | PMinSize | PMaxSize;
  XSetWMNormalHints(xvar->display,win,&hints);
}
/*
** mlx_int.h for mlx in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Jul 31 16:45:48 2000 Charlie Root
** Last update Wed May 25 16:44:16 2011 Olivier Crouzet
*/



/*
** Internal settings for MiniLibX
*/

#ifndef MLX_INT_H

# define MLX_INT_H

# include <stdlib.h>
# include <stdio.h>
# include <string.h>
# include <unistd.h>
# include <fcntl.h>
# include <sys/mman.h>
# include <X11/Xlib.h>
# include <X11/Xutil.h>
# include <sys/ipc.h>
# include <sys/shm.h>
# include <X11/extensions/XShm.h>
# include <X11/XKBlib.h>
/* #include	<X11/xpm.h> */


# define MLX_TYPE_SHM_PIXMAP 3
# define MLX_TYPE_SHM 2
# define MLX_TYPE_XIMAGE 1

# define MLX_MAX_EVENT LASTEvent


# define ENV_DISPLAY "DISPLAY"
# define LOCALHOST "localhost"
# define ERR_NO_TRUECOLOR "MinilibX Error : No TrueColor Visual available.\n"
# define WARN_SHM_ATTACH "MinilibX Warning : X server can't attach shared memory.\n"


typedef	struct	s_xpm_col
{
	int		name;
	int		col;
}				t_xpm_col;


struct	s_col_name
{
	char	*name;
	int		color;
};

typedef struct	s_event_list
{
	int		mask;
	int		(*hook)();
	void	*param;
}				t_event_list;


typedef struct	s_win_list
{
	Window				window;
	GC					gc;
	struct s_win_list	*next;
	int					(*mouse_hook)();
	int					(*key_hook)();
	int					(*expose_hook)();
	void				*mouse_param;
	void				*key_param;
	void				*expose_param;
	t_event_list		hooks[MLX_MAX_EVENT];
}				t_win_list;


typedef struct	s_img
{
	XImage			*image;
	Pixmap			pix;
	GC				gc;
	int				size_line;
	int				bpp;
	int				width;
	int				height;
	int				type;
	int				format;
	char			*data;
	XShmSegmentInfo	shm;
}				t_img;

typedef struct	s_xvar
{
	Display		*display;
	Window		root;
	int			screen;
	int			depth;
	Visual		*visual;
	Colormap	cmap;
	int			private_cmap;
	t_win_list	*win_list;
	int			(*loop_hook)();
	void		*loop_param;
	int			use_xshm;
	int			pshm_format;
	int			do_flush;
	int			decrgb[6];
	Atom		wm_delete_window;
	Atom		wm_protocols;
	int 		end_loop;
}				t_xvar;


int				mlx_int_do_nothing();
int				mlx_get_color_value();
int				mlx_int_get_good_color();
int				mlx_int_find_in_pcm();
int				mlx_int_anti_resize_win();
int				mlx_int_wait_first_expose();
int				mlx_int_rgb_conversion();
int				mlx_int_deal_shm();
void			*mlx_int_new_xshm_image();
char			**mlx_int_str_to_wordtab();
void			*mlx_new_image();
int				shm_att_pb();
int				mlx_int_get_visual(t_xvar *xvar);
int				mlx_int_set_win_event_mask(t_xvar *xvar);
int				mlx_int_str_str_cote(char *str,char *find,int len);
int				mlx_int_str_str(char *str,char *find,int len);


#endif
/*
 ** mlx_pixel_put.c for MiniLibX in 
 ** 
 ** Made by Charlie Root
 ** Login   <ol@epitech.net>
 ** 
 ** Started on  Mon Jul 31 19:01:33 2000 Charlie Root
** Last update Tue Sep 25 17:09:49 2001 Charlie Root
 */


#include	"mlx_int.h"



int		mlx_pixel_put(t_xvar *xvar,t_win_list *win,
			      int x,int y,int color)
{
   XGCValues	xgcv;
   
   xgcv.foreground = mlx_int_get_good_color(xvar,color);
   XChangeGC(xvar->display,win->gc,GCForeground,&xgcv);
   XDrawPoint(xvar->display,win->window,win->gc,x,y);
   if (xvar->do_flush)
     XFlush(xvar->display);
}
/*
** mlx_int_param_event.c for MinilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Jul 31 16:37:50 2000 Charlie Root
** Last update Wed Oct  6 13:14:52 2004 Olivier Crouzet
*/

#include	"mlx_int.h"

int	mlx_int_param_undef()
{
}

int	mlx_int_param_KeyPress(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  win->hooks[KeyPress].hook(XkbKeycodeToKeysym(xvar->display,
					       ev->xkey.keycode, 0, 0),
			    win->hooks[KeyPress].param);
}

int	mlx_int_param_KeyRelease(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  win->hooks[KeyRelease].hook(XkbKeycodeToKeysym(xvar->display,
						 ev->xkey.keycode, 0, 0),
			      win->hooks[KeyRelease].param);
}

int	mlx_int_param_ButtonPress(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  win->hooks[ButtonPress].hook(ev->xbutton.button,ev->xbutton.x,ev->xbutton.y,
			       win->hooks[ButtonPress].param);
}

int	mlx_int_param_ButtonRelease(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  win->hooks[ButtonRelease].hook(ev->xbutton.button,
				 ev->xbutton.x, ev->xbutton.y,
				 win->hooks[ButtonRelease].param);
}

int	mlx_int_param_MotionNotify(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  win->hooks[MotionNotify].hook(ev->xbutton.x,ev->xbutton.y,
				win->hooks[MotionNotify].param);
}

int	mlx_int_param_Expose(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  if (!ev->xexpose.count)
    win->hooks[Expose].hook(win->hooks[Expose].param);
}


int	mlx_int_param_generic(t_xvar *xvar, XEvent *ev, t_win_list *win)
{
  win->hooks[ev->type].hook(win->hooks[ev->type].param);
}

int	(*(mlx_int_param_event[]))() =
{
  mlx_int_param_undef,   /* 0 */
  mlx_int_param_undef,
  mlx_int_param_KeyPress,
  mlx_int_param_KeyRelease,  /* 3 */
  mlx_int_param_ButtonPress,
  mlx_int_param_ButtonRelease,
  mlx_int_param_MotionNotify,  /* 6 */
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_Expose,   /* 12 */
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic,
  mlx_int_param_generic
};



#include	"mlx_int.h"

#include	<unistd.h>
#include <X11/extensions/Xrandr.h>

/* global for independant extension */

RRMode	saved_mode = 0;


int			mlx_ext_fullscreen(t_xvar *xvar, t_win_list *win, int fullscreen)
{
  XWindowAttributes	watt;
  int			i;
  int			j;
  XRRScreenResources	*res;
  XRROutputInfo		*o_info;
  XRRCrtcInfo		*crtc;
  RRMode		mode_candidate;
  int			idx_output;
  int			idx_candidate;

  if (!XGetWindowAttributes(xvar->display, win->window, &watt))
    return (0);

  res = XRRGetScreenResources(xvar->display, xvar->root);
  o_info = NULL;
  idx_output = -1;
  i = res->noutput;
  while (i--)
    {
      o_info = XRRGetOutputInfo(xvar->display, res, res->outputs[i]);
      if (o_info->connection == RR_Connected)
	{
	  idx_output = i;
	  i = 0;
	}
      else
	XRRFreeOutputInfo(o_info);
    }
  if (!o_info)
    {
      XRRFreeScreenResources(res);
      return (0);
    }
  
  idx_candidate = -1;
  i = o_info->nmode;
  while (i--)
    {
      j = res->nmode;
      while (j--)
	if (res->modes[j].id == o_info->modes[i])
	  if (res->modes[j].width >= watt.width && res->modes[j].height >= watt.height &&
	      (idx_candidate == -1 || res->modes[idx_candidate].width > res->modes[j].width ||
	       res->modes[idx_candidate].height > res->modes[j].height) )
	    idx_candidate = i;
    }
  if (idx_candidate < 0)
    {
      XRRFreeOutputInfo(o_info);
      XRRFreeScreenResources(res);
      return (0);
    }
  if (!fullscreen && saved_mode == -1)
    idx_candidate = 0; /* if no clue, uses first mode, usually part of npreferred */
  mode_candidate = o_info->modes[idx_candidate];
  if (!fullscreen)
    mode_candidate = saved_mode;

  crtc = XRRGetCrtcInfo(xvar->display, res, o_info->crtc);
  saved_mode = crtc->mode;

  i = XRRSetCrtcConfig(xvar->display, res, o_info->crtc, CurrentTime, 0, 0, mode_candidate,
		       crtc->rotation, &res->outputs[idx_output], 1);
  if (fullscreen)
    printf("found mode : %d x %d\n Status %d\n", res->modes[idx_candidate].width, res->modes[idx_candidate].height, i);
  else
    printf("back previous mode\n");
  
  XMoveWindow(xvar->display, win->window, 0, 0);
  XMapRaised(xvar->display, win->window);

  if (fullscreen)
    {
      //      XGrabPointer(xvar->display, win->window, True, 0, GrabModeAsync, GrabModeAsync, win->window, 0L, CurrentTime);
      XGrabKeyboard(xvar->display, win->window, False, GrabModeAsync, GrabModeAsync, CurrentTime);
    }
  else
    {
      XUngrabPointer(xvar->display, CurrentTime);
      XUngrabKeyboard(xvar->display, CurrentTime);
    }

  XSync(xvar->display, False);
  sleep(1);

  XRRFreeCrtcInfo(crtc);
  XRRFreeOutputInfo(o_info);
  XRRFreeScreenResources(res);
}
/*
** mlx_new_window.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Mon Jul 31 17:29:02 2000 Charlie Root
** Last update Thu Oct  4 15:44:43 2001 Charlie Root
*/


/*
** We do not use White/BlackPixel macro, TrueColor Visual make sure
** 0 is black & -1 is white
**
** With mlx_int_wait_first_expose, no flush is needed.
*/

#include	"mlx_int.h"


void	*mlx_new_window(t_xvar *xvar,int size_x,int size_y,char *title)
{
	t_win_list				*new_win;
	XSetWindowAttributes	xswa;
	XGCValues				xgcv;

	xswa.background_pixel = 0;
	xswa.border_pixel = -1;
	xswa.colormap = xvar->cmap;
	/*
	xswa.event_mask = ButtonPressMask | ButtonReleaseMask | ExposureMask |
		KeyPressMask | KeyReleaseMask | StructureNotifyMask;
	*/
	/* xswa.event_mask = ExposureMask; */
	xswa.event_mask = 0xFFFFFF;	/* all events */
	if (!(new_win = malloc(sizeof(*new_win))))
		return ((void *)0);
	new_win->window = XCreateWindow(xvar->display,xvar->root,0,0,size_x,size_y,
					0,CopyFromParent,InputOutput,xvar->visual,
					CWEventMask|CWBackPixel|CWBorderPixel|
					CWColormap,&xswa);
	mlx_int_anti_resize_win(xvar,new_win->window,size_x,size_y);
	XStoreName(xvar->display,new_win->window,title);
	XSetWMProtocols(xvar->display, new_win->window, &(xvar->wm_delete_window), 1);
	xgcv.foreground = -1;
	xgcv.function = GXcopy;
	xgcv.plane_mask = AllPlanes;
	new_win->gc = XCreateGC(xvar->display,new_win->window,
				GCFunction|GCPlaneMask|GCForeground,&xgcv);
	new_win->next = xvar->win_list;
	xvar->win_list = new_win;
	/*
	new_win->mouse_hook = mlx_int_do_nothing;
	new_win->key_hook = mlx_int_do_nothing;
	new_win->expose_hook = mlx_int_do_nothing;
	*/
	bzero(&(new_win->hooks), sizeof(new_win->hooks));
	XMapRaised(xvar->display,new_win->window);
	mlx_int_wait_first_expose(xvar,new_win->window);
	return (new_win);
}
/*
** mlx_loop_hook.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Aug  3 11:49:06 2000 Charlie Root
** Last update Fri Feb 23 17:11:39 2001 Charlie Root
*/


#include	"mlx_int.h"




int	mlx_loop_hook(t_xvar *xvar,int (*funct)(),void *param)
{
  xvar->loop_hook = funct;
  xvar->loop_param = param;
}
/*
** mlx_hook.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Aug  3 11:49:06 2000 Charlie Root
** Last update Fri Jan 28 17:05:28 2005 Olivier Crouzet
*/


#include	"mlx_int.h"




int	mlx_hook(t_win_list *win, int x_event, int x_mask, 
		 int (*funct)(),void *param)
{
  win->hooks[x_event].hook = funct;
  win->hooks[x_event].param = param;
  win->hooks[x_event].mask = x_mask;
}


int	mlx_do_key_autorepeatoff(t_xvar *xvar)
{
  XAutoRepeatOff(xvar->display);
}

int	mlx_do_key_autorepeaton(t_xvar *xvar)
{
  XAutoRepeatOn(xvar->display);
}


int	mlx_do_sync(t_xvar *xvar)
{
  XSync(xvar->display, False);
}
/*
** mlx_clear_window.c for MiniLibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Thu Sep  7 19:46:15 2000 Charlie Root
** Last update Tue Sep 25 17:11:19 2001 Charlie Root
*/



#include	"mlx_int.h"


int		mlx_clear_window(t_xvar *xvar,t_win_list *win)
{
  XClearWindow(xvar->display,win->window);
  if (xvar->do_flush)
    XFlush(xvar->display);
}
/*
** mlx_destroy_image.c for MinilibX in 
** 
** Made by Charlie Root
** Login   <ol@epitech.net>
** 
** Started on  Tue Mar 12 10:25:15 2002 Charlie Root
** Last update Tue May 15 16:45:54 2007 Olivier Crouzet
*/


#include	"mlx_int.h"


int	mlx_destroy_image(t_xvar *xvar, t_img *img)
{
  if (img->type == MLX_TYPE_SHM_PIXMAP ||
      img->type == MLX_TYPE_SHM)
    {
      XShmDetach(xvar->display, &(img->shm));
      shmdt(img->shm.shmaddr);
      /* shmctl IPC_RMID already done */
    }
  XDestroyImage(img->image);  /* For image & shm-image. Also free img->data */
  XFreePixmap(xvar->display, img->pix);
  if (img->gc)
    XFreeGC(xvar->display, img->gc);
  free(img);
  if (xvar->do_flush)
    XFlush(xvar->display);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 18:24:35 by elavrich          #+#    #+#             */
/*   Updated: 2025/11/13 14:17:56 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

int	load_map(t_map *map)
{
	int		fd;
	char	*line;
	int		count;

	count = 0;
	fd = open(map->file, O_RDONLY);
	line = get_next_line(fd);
	while (line)
	{
		count++;
		free(line);
		line = get_next_line(fd);
	}
	if(close(fd))
		  perror("close");
	map->count = count;
	map->copy = malloc((count + 1) * sizeof(char *));
	if (!map->copy)
		return (0);
	create_copy(map);
	return (1);
}
void	init_player_direction(t_cub3D *cub3D)
{
	t_player	*p;

	p = cub3D->player;
	if (p->dir == 'N')
	{
		p->dir_x = 0;
		p->dir_y = -1;
		p->plane_x = 0.66;
		p->plane_y = 0;
	}
	else if (p->dir == 'S')
	{
		p->dir_x = 0;
		p->dir_y = 1;
		p->plane_x = -0.66;
		p->plane_y = 0;
	}
	else if (p->dir == 'E')
	{
		p->dir_x = 1;
		p->dir_y = 0;
		p->plane_x = 0;
		p->plane_y = 0.66;
	}
	else if (p->dir == 'W')
	{
		p->dir_x = -1;
		p->dir_y = 0;
		p->plane_x = 0;
		p->plane_y = -0.66;
	}
}

int	init_player(t_cub3D *cub3D)
{
	int	x;
	int	y;

	y = 0;
	while (cub3D->map->copy[y])
	{
		x = 0;
		while (cub3D->map->copy[y][x])
		{
			if (cub3D->map->copy[y][x] == 'N' ||
				cub3D->map->copy[y][x] == 'S' ||
				cub3D->map->copy[y][x] == 'E' ||
				cub3D->map->copy[y][x] == 'W')
			{
				cub3D->player->dir = cub3D->map->copy[y][x];
				cub3D->player->pos_x = (float)x + 0.5;
				cub3D->player->pos_y = (float)y + 0.5;
				cub3D->map->copy[y][x] = '0';
				init_player_direction(cub3D);
				if (DEBUG_INIT)
				{
					printf("Player spawned at: (%.2f, %.2f)\n", 
						cub3D->player->pos_x, cub3D->player->pos_y);
					printf("Direction vector: (%.2f, %.2f)\n",
						cub3D->player->dir_x, cub3D->player->dir_y);
					printf("Map dimensions: %d lines\n", cub3D->map->count);

				}
				return (1);
			}
			x++;
		}
		y++;
	}
	return (1);
}

int	mlx_set(t_cub3D *Cub3D)
{
	Cub3D->win = mlx_new_window(Cub3D->mlx, WIN_WIDTH, WIN_HEIGHT, "cub3D");
	if (!Cub3D->win)
		return (0);
	Cub3D->img.img = mlx_new_image(Cub3D->mlx, WIN_WIDTH, WIN_HEIGHT); //what is this for? there is no image (aside textures)
	if (!Cub3D->img.img)
		return (0);
	Cub3D->img.addr = mlx_get_data_addr(Cub3D->img.img,
		&Cub3D->img.bits_per_pixel,
		&Cub3D->img.line_len,
		&Cub3D->img.endian);
	configs(Cub3D->map);
	if(!walls_check(Cub3D->map))
		return (printf("Not enclosed by walls\n"), 0);
	if (!init_player(Cub3D))
		return (0);
	render_3d_view(Cub3D);
	debug_player_spawn_simple(Cub3D);
	debug_print_map_raw(Cub3D->map);
	mlx_hook(Cub3D->win, 17, 0, ft_close, (void *)Cub3D);
	mlx_hook(Cub3D->win, 2, 1L << 0, ft_key_press, (void *)Cub3D);
	mlx_hook(Cub3D->win, 3, 1L << 1, ft_key_release, (void *)Cub3D);
	mlx_loop(Cub3D->mlx);
	return (1);
}

void	set_textures_col(t_map *map, int op, char *path)
{
	int		width;
	int		height;
	int		len;
	t_cub_img	*texture;

	width = 64;
	height = 64;
	len = ft_strlen(path);
	
	// Trim whitespace
	while (len > 0 && (path[len - 1] == '\n' || path[len - 1] == ' ' || 
			path[len - 1] == '\t'))
		path[--len] = '\0';
	// Select which texture to load
	if (op == NT)
		texture = &map->N_text;
	else if (op == ST)
		texture = &map->S_text;
	else if (op == ET)
		texture = &map->E_text;
	else if (op == WT)
		texture = &map->W_text;
	else
		return;
	
	texture->img = mlx_xpm_file_to_image(map->cub3D->mlx, path, &width, &height);
	if (!texture->img)
	{
		printf("Error: failed to load texture from '%s'\n", path);
		return;
	}
	if (texture->img)
	{
		// Get the data address for direct pixel access
		texture->addr = mlx_get_data_addr(texture->img, 
			&texture->bits_per_pixel,
			&texture->line_len, 
			&texture->endian);
	}
}

void	set_colors(t_map *map, int op, char *line)
{
	int	colors[3];
	
	extract_color(line, colors);
	if (op == F)
	{
		map->f_red = colors[0];
		map->f_green = colors[1];
		map->f_blue = colors[2];
	}
	else if (op == C)
	{
		map->c_red = colors[0];
		map->c_green = colors[1];
		map->c_blue = colors[2];
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 18:24:30 by elavrich          #+#    #+#             */
/*   Updated: 2025/11/10 18:13:51 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

int	main(int argc, char **argv)
{
	t_cub3D		cub3D;
	t_player	player;
	t_map		*tmap;

	if (arg_error(argc, argv))
		return (0);
	tmap = malloc(sizeof(t_map));
	if (!tmap)
		return (1);
	cub3D.mlx = mlx_init(&cub3D);
	if(!cub3D.mlx)
		return 1;
	tmap->file = argv[1];
	if (!load_map(tmap))
		return (free(tmap), 1);
	ft_memset(&player, 0, sizeof(t_player));
	player.speed = MOVESPEED;
	cub3D.player = &player;
	cub3D.player->speed = 0.1;
	cub3D.map = tmap;
	tmap->cub3D = &cub3D;
	if (!mlx_set(&cub3D))
		return (free(tmap), 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_pointer.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 15:37:47 by elavrich          #+#    #+#             */
/*   Updated: 2025/11/12 09:43:13 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

unsigned long	ft_ptr(unsigned long num)
{
	char			*symbols;
	unsigned long	value;

	value = 0;
	symbols = "0123456789abcdef";
	if (num >= 16)
	{
		value += ft_ptr(num / 16);
	}
	value += write(1, &symbols[num % 16], 1);
	return (value);
}

unsigned long	ft_vptr(unsigned long num, const char *format)
{
	unsigned long	value;
//	char			*symbols;

	(void)format;
//	symbols = "0123456789abcdef";
	value = 0;
	if (!num)
		value += write(1, "(nil)", 5);
	else
	{
		value += write(1, "0x", 2);
		value += ft_ptr(num);
	}
	return (value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_hexlower.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 16:30:50 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/27 16:57:57 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_hexlower(int n, const char *format)
{
	char			*symbols;
	unsigned int	value;
	unsigned int	nn;

	value = 0;
	symbols = "0123456789abcdef";
	nn = (unsigned int)n;
	if (nn >= 16)
	{
		value += ft_hexlower(nn / 16, format);
	}
	value += write(1, &symbols[nn % 16], 1);
	return (value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/25 14:00:34 by elavrich          #+#    #+#             */
/*   Updated: 2024/10/03 17:37:01 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_printf(const char *format, ...)
{
	va_list	args;
	int		count;

	count = 0;
	va_start(args, format);
	while (*format)
	{
		if (ft_c(format) == 'd' || ft_c(format) == 'i' || ft_c(format) == 'u')
			count += ft_chosenbr(va_arg(args, int), format++);
		else if (ft_c(format) == 's')
			count += ft_putstr(va_arg(args, char *), format++);
		else if (ft_c(format) == 'p')
			count += ft_vptr((unsigned long)va_arg(args, void *), format++);
		else if (ft_c(format) == '%')
			count += ft_putchar((char) '%', format++);
		else if (ft_c(format) == 'c')
			count += ft_putchar((char)va_arg(args, int), format++);
		else if (ft_c(format) == 'x' || ft_c(format) == 'X')
			count += ft_chosehex(va_arg(args, int), format++);
		else
			count += ft_putchar_onear(*format);
		format++;
	}
	va_end(args);
	return (count);
}

// int	main(void)
// {
// 	int	a;
// 	int	*ptr;

// 	a = 4;
// 	ptr = &a;
// 	ft_printf(" %u ", a);
// 	ft_printf(" %u\n ", a);

// 	ft_printf(" %d ", a);
// 	printf(" %d\n ", a);

// 	ft_printf(" %i ", a);
// 	printf(" %i\n ", a);

// 	ft_printf(" %x", 455);
// 	printf(" %x\n ", 455);

// 	ft_printf(" %X ", 455);
// 	printf(" %X\n ", 455);

// 	ft_printf(" %p ", ptr);
// 	printf(" %p\n ", ptr);

// 	ft_printf(" %c ", 'a');
// 	printf(" %c\n ", 'a');

// 	ft_printf(" %s ", "string");
// 	printf(" %s\n ", "string");

// 	ft_printf(" %% ");
// 	printf(" %%\n ");

// 	ft_printf("abc65d ");
// 	printf("abc65d\n ");

// 	ft_printf("%d\n", ft_printf("%s\n", NULL));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:25 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/26 22:40:31 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_putchar(char c, const char *format)
{
	(void)format;
	write(1, &c, 1);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putunsint.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 16:17:37 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/27 21:57:11 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_putunsint(unsigned int n, const char *format)
{
	char	num;
	int		i;

	i = 0;
	if (n >= 10)
		i += ft_putnbr(n / 10, format);
	num = (n % 10) + '0';
	write(1, &num, 1);
	i++;
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/21 00:23:37 by elavrich          #+#    #+#             */
/*   Updated: 2024/10/01 20:21:41 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FT_PRINTF_H
# define FT_PRINTF_H
# include <stdarg.h>
# include <stddef.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

int				ft_atoi(const char *nptr);
int				ft_printf(const char *format, ...);
int				ft_chosehex(int n, const char *format);
int				ft_hexlower(int n, const char *format);
int				ft_hexupper(int n, const char *format);
unsigned long	ft_vptr(unsigned long num, const char *format);
int				ft_putchar_onear(char c);
char			ft_c(const char *format);
int				ft_putchar(char c, const char *format);
int				ft_putstr(char *s, const char *format);
int				ft_putnbr(int n, const char *format);
void			ft_newl(void);
int				ft_putunsint(unsigned int n, const char *format);
int				ft_chosenbr(int n, const char *format);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_onear.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 20:36:10 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/27 17:36:20 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_putchar_onear(char c)
{
	write(1, &c, 1);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnewl.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:22 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/26 22:40:26 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

void	ft_newl(void)
{
	write(1, "\n", 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:57:03 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/25 17:16:08 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>

static int	space(char c)
{
	if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v'
		|| c == '\f')
		return (1);
	else
		return (0);
}

int	ft_atoi(const char *nptr)
{
	int	i;
	int	result;

	i = 0;
	result = 0;
	while (space(nptr[i]))
		++i;
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + nptr[i] - '0';
		++i;
	}
	++i;
	return (result);
}

// int	main(void)
// {
// 	char	str[100] = "-+977 a8786";

// 	printf("%i\n %i", ft_atoi(str), atoi(str));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:18 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/27 21:37:16 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_putnbr(int n, const char *format)
{
	char	num;
	int		i;
	long	nn;

	nn = (long)n;
	i = 0;
	if (nn == -2147483648)
	{
		write(1, "-2147483648", 11);
		return (11);
	}
	if (nn < 0)
	{
		write(1, "-", 1);
		nn = -nn;
		i++;
	}
	if (nn >= 10)
	{
		i += ft_putnbr((nn / 10), format);
	}
	num = (nn % 10) + '0';
	write(1, &num, 1);
	i++;
	return (i);
}
// int main()
// {
// 	ft_putnbr_fd(-21474848, -1);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:16 by elavrich          #+#    #+#             */
/*   Updated: 2024/10/01 20:16:37 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_putstr(char *s, const char *format)
{
	int	i;

	i = 0;
	(void)format;
	if (!s)
	{
		write(1, "(null)", 6);
		return (6);
	}
	while (s[i])
	{
		write(1, &s[i], 1);
		i++;
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_chosehex.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 21:20:39 by elavrich          #+#    #+#             */
/*   Updated: 2024/10/01 20:21:54 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_chosehex(int n, const char *format)
{
	int	count;

	count = 0;
	if (ft_c(format) == 'x')
		count += ft_hexlower(n, format);
	else
		count += ft_hexupper(n, format);
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_hexupper.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 16:34:38 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/27 16:58:56 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_hexupper(int n, const char *format)
{
	char			*symbols;
	int				value;
	unsigned int	nn;

	nn = (unsigned int)n;
	value = 0;
	symbols = "0123456789ABCDEF";
	if (nn >= 16)
	{
		value += ft_hexupper(nn / 16, format);
	}
	value += write(1, &symbols[nn % 16], 1);
	return (value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_chosenbr.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 22:23:26 by elavrich          #+#    #+#             */
/*   Updated: 2024/10/01 20:22:04 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_chosenbr(int n, const char *format)
{
	int	count;

	count = 0;
	if (ft_c(format) == 'u')
		count += ft_putunsint(n, format);
	else
		count += ft_putnbr(n, format);
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_c.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 16:25:05 by elavrich          #+#    #+#             */
/*   Updated: 2024/10/01 20:19:37 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

char	ft_c(const char *format)
{
	if (*format == '%' && *(format + 1) == 'd')
		return ('d');
	if (*format == '%' && *(format + 1) == 's')
		return ('s');
	if (*format == '%' && *(format + 1) == 'i')
		return ('i');
	if (*format == '%' && *(format + 1) == '%')
		return ('%');
	if (*format == '%' && *(format + 1) == 'c')
		return ('c');
	if (*format == '%' && *(format + 1) == 'p')
		return ('p');
	if (*format == '%' && *(format + 1) == 'u')
		return ('u');
	if (*format == '%' && *(format + 1) == 'x')
		return ('x');
	if (*format == '%' && *(format + 1) == 'X')
		return ('X');
	return ('\0');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/21 00:23:37 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/23 15:58:14 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LIBFT_H
# define LIBFT_H
# include <stddef.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

size_t				ft_strlcat(char *dst, const char *src, size_t size);
char				*ft_substr(char const *s, unsigned int start, size_t len);
char				*ft_strmapi(char const *s, char (*f)(unsigned int, char));
void				ft_striteri(char *s, void (*f)(unsigned int, char *));
char				*ft_strdup(const char *s);
void				ft_bzero(void *s, size_t n);
int					ft_isalpha(int c);
int					ft_isdigit(int c);
int					ft_isprint(int c);
int					ft_isalnum(int c);
size_t				ft_strlen(const char *str);
void				*ft_memcpy(void *dest, const void *src, size_t n);
int					ft_isascii(int c);
int					ft_tolower(int c);
int					ft_toupper(int c);
void				*ft_memset(void *s, int c, size_t n);
size_t				ft_strlcpy(char *dst, char *src, size_t size);
char				*ft_strchr(const char *s, int c);
char				*ft_strrchr(const char *s, int c);
int					ft_memcmp(const void *s1, const void *s2, size_t n);
void				*ft_memmove(void *dest, const void *src, size_t n);
int					ft_strncmp(const char *s1, const char *s2, unsigned int n);
void				*ft_memchr(const void *s, int c, size_t n);
char				*ft_strnstr(const char *big, const char *little,
						size_t len);
int					ft_atoi(const char *nptr);
void				ft_putchar_fd(char c, int fd);
void				ft_putstr_fd(char *s, int fd);
void				ft_putendl_fd(char *s, int fd);
char				**ft_split(const char *s, char c);
void				*ft_calloc(size_t nmemb, size_t size);
void				ft_putnbr_fd(int n, int fd);
char				*ft_strtrim(char const *s1, char const *set);
char				*ft_strjoin(char const *s1, char const *s2);
char				*ft_itoa(int n);

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}					t_list;

t_list				*ft_lstnew(void *content);
void				ft_lstadd_front(t_list **lst, t_list *new);
int					ft_lstsize(t_list *lst);
t_list				*ft_lstlast(t_list *lst);
void				ft_lstadd_back(t_list **lst, t_list *new);
void				ft_lstdelone(t_list *lst, void (*del)(void *));
void				ft_lstclear(t_list **lst, void (*del)(void *));
void				ft_lstiter(t_list *lst, void (*f)(void *));
t_list				*ft_lstmap(t_list *lst, void *(*f)(void *),
						void (*del)(void *));
#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 18:05:35 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 19:21:24 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	while (lst != NULL)
	{
		(*f)(lst->content);
		lst = lst->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 20:22:12 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 20:34:27 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	j;
	size_t	dst_len;
	size_t	src_len;

	i = 0;
	j = 0;
	dst_len = ft_strlen(dst);
	src_len = ft_strlen(src);
	if (size == 0)
		return (src_len);
	if (size <= dst_len)
		return (src_len + size);
	while (dst[i] != '\0')
		i++;
	while (src[j] != '\0' && i < size - 1)
	{
		dst[i] = src[j];
		i++;
		j++;
	}
	dst[i] = '\0';
	return (dst_len + src_len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 20:13:27 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 16:36:17 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
//#include "ft_strlen.c"

static char	*ft_strcpy(char *dest, const char *src)
{
	unsigned int	i;

	i = 0;
	while (src[i])
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

char	*ft_strdup(const char *s)
{
	char	*dst;

	dst = malloc(ft_strlen(s) + 1);
	if (!dst)
		return (NULL);
	ft_strcpy(dst, s);
	return (dst);
}

// int	main(void)
// {
// 	printf("%s", ft_strdup("dsgggfdfsdgf"));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:20 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 21:05:01 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	int		i;
	char	*char_ptr;

	i = 0;
	char_ptr = (char *)s;
	while (char_ptr[i])
	{
		if (char_ptr[i] == (unsigned char)c)
		{
			return (&char_ptr[i]);
		}
		i++;
	}
	if ((unsigned char)c == '\0')
		return (&char_ptr[i]);
	return (NULL);
}
// int	main(void)
// {
// 	const char	s[] = "teste";
// 	char ch = 'e';
// 	printf("%s",ft_strchr(s,ch));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:55:52 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 16:31:43 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include "ft_strlen.c"
#include "libft.h"

static char	*ft_strncpy_2(char *dest, const char *src, unsigned int n)
{
	unsigned int	i;

	i = 0;
	while (src[i] && i < n)
	{
		dest[i] = src[i];
		i++;
	}
	while (i < n)
	{
		dest[i] = '\0';
		i++;
	}
	return (dest);
}

static int	is_in_set(char c, const char *set)
{
	while (*set)
	{
		if (c == *set)
			return (1);
		set++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	int		start;
	int		end;
	char	*trimmed;

	if (!s1 || !set)
		return (NULL);
	start = 0;
	while (s1[start] && is_in_set(s1[start], set))
		start++;
	end = ft_strlen(s1) - 1;
	while (end >= start && is_in_set(s1[end], set))
		end--;
	trimmed = malloc((end - start + 2) * sizeof(char));
	if (!trimmed)
		return (NULL);
	ft_strncpy_2(trimmed, &s1[start], end - start + 1);
	trimmed[end - start + 1] = '\0';
	return (trimmed);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/17 16:34:42 by elavrich          #+#    #+#             */
/*   Updated: 2024/12/04 18:23:41 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	is_separator(char c, const char charset)
{
	return (c == charset);
}

static int	count_segments(const char *str, char charset)
{
	int	count;
	int	in_segment;

	count = 0;
	in_segment = 0;
	while (*str)
	{
		if (is_separator(*str, charset))
		{
			if (in_segment)
			{
				in_segment = 0;
			}
		}
		else
		{
			if (!in_segment)
			{
				count++;
				in_segment = 1;
			}
		}
		str++;
	}
	return (count);
}

static char	*copy_segment(const char *s, int start, int end)
{
	char	*segment;
	int		length;
	int		i;

	i = 0;
	length = end - start;
	segment = malloc(length + 1);
	if (!segment)
		return (NULL);
	while (i < length)
	{
		segment[i] = s[start + i];
		i++;
	}
	segment[length] = '\0';
	return (segment);
}

char	**ft_split(const char *s, char c)
{
	int		i;
	int		k;
	char	**array;
	int		start;

	i = 0;
	k = 0;
	array = malloc((count_segments(s, c) + 1) * sizeof(char *));
	if (!array)
		return (free(array), NULL);
	while (s[i])
	{
		if (s[i] != c)
		{
			start = i;
			while (s[i] && s[i] != c)
				i++;
			array[k] = copy_segment(s, start, i);
			k++;
		}
		else
			i++;
	}
	array[k] = NULL;
	return (array);
}

void	f_free(char **split_argc)
{
	int	i;

	i = 0;
	if (!split_argc)
		return ;
	while (split_argc[i])
	{
		free(split_argc[i]);
		i++;
	}
	free(split_argc);
}
// int	main(void)
// {
// 	char	s1[90] = "split ||this|for|me|||||!|";
// 	char	s2;
// 	char	**result;
// 	int		i;

// 	s2 = '|';
// 	i = 0;
// 	result = ft_split(s1, s2);
// 	while (result[i])
// 	{
// 		printf("%s", result[i]);
// 		i++;
// 	}
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:42:02 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 17:51:07 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next)
	{
		lst = lst->next;
	}
	return (lst);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/20 18:14:12 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 21:36:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	int_len(long nbr)
{
	int	count;

	count = 0;
	if (nbr < 0)
	{
		count++;
		nbr = -nbr;
	}
	if (nbr == 0)
		count++;
	while (nbr != 0)
	{
		nbr /= 10;
		count++;
	}
	return (count);
}

char	*ft_itoa(int n)
{
	char	*num;
	int		len;
	int		i;
	long	nbr;

	nbr = n;
	len = int_len(nbr);
	i = len - 1;
	num = malloc(len + 1);
	if (!num)
		return (NULL);
	if (n == 0)
		num[i] = '0';
	if (n < 0)
	{
		num[0] = '-';
		nbr *= -1;
	}
	while (nbr != 0)
	{
		num[i--] = ((nbr % 10) + 48);
		nbr = nbr / 10;
	}
	num[len] = '\0';
	return (num);
}
// int	main(void)
// {
// 	printf("%s", ft_itoa(-30));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/11 15:18:15 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/18 16:46:26 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, unsigned int n)
{
	unsigned int	i;

	i = 0;
	while ((s1[i] || s2[i]) && i < n)
	{
		if ((unsigned char)s1[i] != (unsigned char)s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return (0);
}
// int	main(void)
// {
// 	char	str1[50] = "";
// 	char	str2[50] = "dsfsd";

// 	printf("%d\n %d", ft_strncmp(str1, str2, 10), strncmp(str1, str2, 10));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 15:59:22 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/20 17:30:44 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	size_t			i;
	unsigned char	*b;

	b = (unsigned char *)s;
	i = 0;
	while (i < n)
	{
		b[i] = (unsigned char)c;
		i++;
	}
	return (s);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:55:37 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 16:27:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include "ft_strlen.c"
#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	size_t	i;
	char	*str;

	i = 0;
	if (start >= ft_strlen(s))
	{
		str = malloc(1);
		if (str)
			str[0] = '\0';
		return (str);
	}
	if (len > ft_strlen(s) - start)
		len = ft_strlen(s) - start;
	str = malloc((len + 1) * sizeof(char));
	if (!str)
		return (NULL);
	while (i < len && s[start + i])
	{
		str[i] = s[start + i];
		i++;
	}
	str[i] = '\0';
	return (str);
}
// int	main(void)
// {
// 	char	*s;
// 	char	*sub;

// 	s = "Hola";
// 	sub = ft_substr(s, 0, 4);
// 	if (sub)
// 	{
// 		printf("%s", sub);
// 		free(sub);
// 	}
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:58:40 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/19 19:58:43 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_toupper(int c)
{
	if (c >= 97 && c <= 122)
	{
		return (c - 32);
	}
	return (c);
}

// int	main(void)
// {
// 	char	str = 'z';

// 	printf("%c", ft_toupper(str));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:26:52 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/17 16:52:47 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= 48 && c <= 57)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:58:35 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/19 19:58:37 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_tolower(int c)
{
	if (c >= 65 && c <= 90)
	{
		return (c + 32);
	}
	return (c);
}

// int	main(void)
// {
// 	char	str = 'a';

// 	printf("%c", ft_tolower(str));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:02 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/18 16:12:34 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <string.h>

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	size_t	i;
	char	*char_ptr;
	char	*char_ptr2;

	i = 0;
	char_ptr = (char *)dest;
	char_ptr2 = (char *)src;
	if (n == 0 || dest == src)
	{
		return (dest);
	}
	while (i < n)
	{
		char_ptr[i] = char_ptr2[i];
		i++;
	}
	return (dest);
}
// int	main(void)
// {
// 	char	dest[90] = "";
// 	char	src[90] = "";
// 	char	dest2[90] = "";
// 	char	src2[90] = "";

// 	ft_memcpy(dest, src, 9);
// 	memcpy(dest2, src2, 9);
// 	printf("%s", dest);
// 	printf("\n");
// 	printf("%s", dest2);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:09 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 21:27:27 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0 || dest == src)
		return (dest);
	if (dest > src)
	{
		i = n;
		while (i > 0)
		{
			i--;
			*(char *)(dest + i) = *(char *)(src + i);
		}
	}
	else
	{
		while (i < n)
		{
			*(char *)(dest + i) = *(char *)(src + i);
			i++;
		}
	}
	return (dest);
}
// int main()
// {
// 	char dest[90] = "kkkk";
// 	char src[90] = "gdgfdg";
// 	ft_memmove(dest, src, 8);
// 	printf("%s", dest);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:45 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/18 18:42:20 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <string.h>

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t		i;
	const char	*char_ptr;
	const char	*char_ptr2;

	i = 0;
	char_ptr = (const char *)s1;
	char_ptr2 = (const char *)s2;
	while (i < n)
	{
		if ((unsigned char)char_ptr[i] != (unsigned char)char_ptr2[i])
			return ((unsigned char)char_ptr[i] - (unsigned char)char_ptr2[i]);
		i++;
	}
	return (0);
}
// int	main(void)
// {
// 	char	str1[50] = "dsfsdfgdff";
// 	char	str2[50] = "ds";

// 	printf("%i\n %i", ft_memcmp(str1, str2, 5), memcmp(str1, str2, 5));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/20 18:04:17 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 18:10:33 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
//#include "ft_strlen.c"
// #include <ctype.h>
// #include <stdio.h>

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	unsigned int	i;
	char			*new_str;
	size_t			len;

	len = ft_strlen(s);
	new_str = malloc((len + 1) * sizeof(char));
	if (!new_str)
		return (NULL);
	i = 0;
	while (i < len)
	{
		new_str[i] = (*f)(i, s[i]);
		i++;
	}
	new_str[i] = '\0';
	return (new_str);
}
// char	to_uppercase(unsigned int i, char c)
// {
// 	return (toupper(c));
// }

// int	main(void)
// {
// 	char const	s1[] = "gdfgsdgdg";
// 	char		*result;

// 	result = ft_strmapi(s1, to_uppercase);
// 	printf("%s\n", result);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:51:47 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 20:20:52 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*current;

	if (!new || !lst)
		return ;
	if (*lst == NULL)
	{
		*lst = new;
		return ;
	}
	current = ft_lstlast(*lst);
	current->next = new;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/17 16:39:37 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/20 17:31:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include "ft_strlen.c"
#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	int		i;
	int		j;
	int		total_length;
	char	*concat;

	if (!s1 || !s2)
		return (NULL);
	total_length = ft_strlen(s1) + ft_strlen(s2);
	concat = (char *)malloc((total_length + 1) * sizeof(char));
	if (!concat)
		return (NULL);
	i = 0;
	while (s1[i])
	{
		concat[i] = s1[i];
		i++;
	}
	j = 0;
	while (s2[j])
	{
		concat[i + j] = s2[j];
		j++;
	}
	concat[i + j] = '\0';
	return (concat);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:58:10 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/19 19:58:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlcpy(char *dst, char *src, size_t size)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (src[j])
		j++;
	if (size == 0)
		return (j);
	while (src[i] && i < (size - 1))
	{
		dst[i] = src[i];
		i++;
	}
	dst[i] = '\0';
	return (j);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:18 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 22:23:02 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	char	num;

	if (n == -2147483648)
	{
		write(fd, "-2147483648", 11);
		return ;
	}
	if (n < 0)
	{
		write(fd, "-", 1);
		n = -n;
	}
	if (n >= 10)
		ft_putnbr_fd(n / 10, fd);
	num = (n % 10) + '0';
	write(fd, &num, 1);
}
// int main()
// {
// 	ft_putnbr_fd(-21474848, -1);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 20:13:17 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/20 17:31:00 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	if (nmemb == 0 || size == 0)
		return (malloc(0));
	ptr = malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_memset(ptr, 0, nmemb * size);
	return (ptr);
}
// int	main(void)
// {
// 	int	n;
// 	int	*array;

// 	n = 5;
// 	array = (int *)calloc(n, sizeof(int));
// 	for (int i = 0; i < n; i++) {
//       printf("%d ", array[i]);
//    }
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 15:59:52 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/17 21:30:59 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <strings.h>

void	ft_bzero(void *s, size_t n)
{
	size_t	i;
	char	*char_ptr;

	i = 0;
	char_ptr = (char *)s;
	while (i < n)
	{
		char_ptr[i] = 0;
		i++;
	}
}

// int	main(void)
// {
// 	char	str[90] = "erkgherkghfd0ukgauh";
// 	char	str2[90] = "erkgherkghfd0ukgauh";

// 	bzero(str, 20);
// 	ft_bzero(str2, 20);
// 	printf("%s, %s", str, str2);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:57:03 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/22 12:59:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
#include <unistd.h>

static int	space(char c)
{
	if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v'
		|| c == '\f')
		return (1);
	else
		return (0);
}

int	ft_atoi(const char *nptr)
{
	int	i;
	int	sign;
	int	result;

	sign = 1;
	i = 0;
	result = 0;
	while (space(nptr[i]))
		++i;
	if (nptr[i] == '-')
	{
		sign *= -1;
		++i;
	}
	else if (nptr[i] == '+')
	{
		i++;
	}
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + nptr[i] - '0';
		++i;
	}
	++i;
	return (result * sign);
}

// int	main(void)
// {
// 	char	str[100] = "-+977 a8786";

// 	printf("%i\n %i", ft_atoi(str), atoi(str));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:16 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 22:10:00 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	int	i;

	i = 0;
	while (s[i])
	{
		write(fd, &s[i], 1);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:35:24 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 20:20:45 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	new->next = *lst;
	*lst = new;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:54 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/18 19:39:10 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdio.h>
#include <string.h>

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	k;

	k = 0;
	i = 0;
	if (little[0] == '\0')
		return ((char *)big);
	i = 0;
	while (big[i] && i < len)
	{
		k = 0;
		while (big[i + k] == little[k] && i + k < len)
		{
			k++;
			if (little[k] == '\0')
				return ((char *)(big + i));
		}
		i++;
	}
	return (NULL);
}
// int	main(void)
// {
// 	const char	big[90] = "gdgfkdag";
// 	const char	little[90] = "a";
// 	size_t		len;

// 	len = 9;
// 	printf("%s\n", ft_strnstr(big, little, len));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:22 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 22:15:01 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	int	i;

	i = 0;
	while (s[i])
	{
		write(fd, &s[i], 1);
		i++;
	}
	write(fd, "\n", 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:25 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/19 19:56:26 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:39:16 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 19:27:38 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int	i;

	i = 0;
	while (lst != NULL)
	{
		i++;
		lst = lst->next;
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:35 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/18 18:33:25 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t			i;
	unsigned char	*char_ptr;
	unsigned char	c_ptr;

	i = 0;
	char_ptr = (unsigned char *)s;
	c_ptr = (unsigned char)c;
	while (i < n)
	{
		if (char_ptr[i] == c_ptr)
			return ((void *)&char_ptr[i]);
		i++;
	}
	if (i == n)
		return (NULL);
	return (0);
}
// int	main(void)
// {
// 	char	str[90] = "hkjdfhgjkh";
// 	char	str2[90] = "hkjdfhgjkh";

// 	ft_memchr(str, 200, 10);
// 	memchr(str2, 200, 10);
// 	printf("%s\n", str);
// 	printf("%s", str2);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:58:16 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/19 21:22:54 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlen(const char	*str)
{
	size_t	i;

	i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return (i);
}

/*int main()
{
	int lenght = ft_strlen("idkwhattowrite");
	printf("%d",lenght);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 16:00:29 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/17 21:11:28 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	int		i;
	char	*char_ptr;

	char_ptr = (char *)s;
	i = 0;
	while (char_ptr[i])
		i++;
	while (i >= 0)
	{
		if (char_ptr[i] == (char)c)
			return (&char_ptr[i]);
		i--;
	}
	if (c == '\0')
		return (&char_ptr[i]);
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:55 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 16:36:23 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int c)
{
	if ((c >= 48 && c <= 57) || (c >= 97 && c <= 122) || (c >= 65 && c <= 90))
	{
		return (1);
	}
	return (0);
}
// int	main(void)
// {
// 	char	c = 'a';
// 	printf("%d", ft_isalnum(c));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:57:47 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/19 19:57:49 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
	{
		return (1);
	}
	return (0);
}

// int	main(void)
// {
// 	printf("%d", ft_isprint('p'));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:29:30 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 19:24:49 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*new;

	new = malloc(sizeof(t_list));
	if (!new)
		return (NULL);
	new->content = content;
	new->next = NULL;
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/20 21:01:03 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 15:32:37 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//#include "ft_strlen.c"
#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char *))
{
	unsigned int	i;

	i = 0;
	while (s[i])
	{
		(*f)(i, &s[i]);
		i++;
	}
}

// void	to_upper(unsigned int i, char *s)
// {
// 	if (*s >= 'a' && *s <= 'z')
// 	{
// 		*s = *s - 32;
// 	}
// }

// int	main(void)
// {
// 	char	s1[] = "gdfgsdgdg";

// 	ft_striteri(s1, to_upper);
// 	printf("%s\n", s1);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 18:00:56 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 18:05:04 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void *))
{
	t_list	*tmp;

	while (*lst)
	{
		tmp = (*lst)->next;
		ft_lstdelone(*lst, del);
		*lst = tmp;
	}
	free(*lst);
	*lst = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/16 15:59:39 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/17 19:14:34 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	if ((c >= 0 && c <= 127))
	{
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:58:31 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 18:00:21 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void *))
{
	del(lst->content);
	free(lst);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 18:09:19 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 20:17:44 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_list;
	t_list	*new_obj;

	new_list = NULL;
	if (!lst)
		return (NULL);
	while (lst)
	{
		new_obj = ft_lstnew(f(lst->content));
		if (!new_obj)
		{
			ft_lstdelone(new_obj, del);
			return (NULL);
		}
		ft_lstadd_back(&new_list, new_obj);
		lst = lst->next;
	}
	return (new_list);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 19:56:50 by elavrich          #+#    #+#             */
/*   Updated: 2024/09/21 16:36:38 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 65 && c <= 90) || (c >= 97 && c <= 122))
	{
		return (1);
	}
	return (0);
}
// int	main(void)
// {
// 	char	c = 'a';
// 	printf("%d", ft_isalpha(c));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 21:39:08 by elavrich          #+#    #+#             */
/*   Updated: 2024/11/22 17:58:19 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# include <fcntl.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 10
# endif

char	*get_next_line(int fd);
int		ft_strlen_g(char *str);
char	*cut_line(char *str);
char	*get_rest(char *str);
char	*ft_strjoin_g(char *s1, char *s2);
char	*read_from_f(int fd, char *read_line);
int		ft_strchr_g(const char *s, char c);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 21:39:18 by elavrich          #+#    #+#             */
/*   Updated: 2024/11/22 18:12:31 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

// Ensures read_line is initialized as an empty string if it is NULL
char	*norm(char *read_line)
{
	if (!read_line)
	{
		read_line = malloc(1);
		if (!read_line)
			return (NULL);
		read_line[0] = '\0';
	}
	return (read_line);
}

// Reads from the file descriptor until a newline or EOF is encountered
char	*read_from_f(int fd, char *read_line)
{
	char	*storage_l;
	int		bytes_read;

	storage_l = malloc(BUFFER_SIZE + 1);
	if (!storage_l)
		return (free(read_line), NULL);
	read_line = norm(read_line);
	if (!read_line)
		return (free(storage_l), NULL);
	bytes_read = 1;
	while (bytes_read > 0)
	{
		bytes_read = read(fd, storage_l, BUFFER_SIZE);
		if (bytes_read < 0)
			return (free(storage_l), free(read_line), NULL);
		storage_l[bytes_read] = '\0';
		read_line = ft_strjoin_g(read_line, storage_l);
		if (!read_line)
			return (free(storage_l), free(read_line), NULL);
		if (ft_strchr_g(storage_l, '\n'))
			break ;
	}
	return (free(storage_l), read_line);
}

// Extracts the first line (up to and including the newline if present)
char	*cut_line(char *str)
{
	int		i;
	char	*fin_line;

	i = 0;
	if (!str || str[0] == '\0')
		return (NULL);
	while (str[i] && str[i] != '\n')
		i++;
	if (str[i] == '\n')
		i++;
	fin_line = malloc(i + 1);
	if (!fin_line)
		return (NULL);
	i = 0;
	while (str[i] && str[i] != '\n')
	{
		fin_line[i] = str[i];
		i++;
	}
	if (str[i] == '\n')
		fin_line[i++] = '\n';
	fin_line[i] = '\0';
	return (fin_line);
}

// Retrieves the remainder of the string after the newline
char	*get_rest(char *str)
{
	int		i;
	int		j;
	char	*remainder;

	j = 0;
	i = 0;
	while (str[j] && str[j] != '\n')
		j++;
	if (!str[j])
		return ((free(str)), NULL);
	j++;
	if (!str[j])
		return ((free(str)), NULL);
	remainder = malloc(ft_strlen_g(str) - j + 1);
	if (!remainder)
		return (free(str), NULL);
	while (str[j])
		remainder[i++] = str[j++];
	remainder[i] = '\0';
	free(str);
	return (remainder);
}

char	*get_next_line(int fd)
{
	static char	*st_line;
	char		*f_line;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	st_line = read_from_f(fd, st_line);
	if (!st_line)
		return (free(st_line), NULL);
	f_line = cut_line(st_line);
	if (!f_line)
	{
		free(st_line);
		st_line = NULL;
		return (NULL);
	}
	st_line = get_rest(st_line);
	if (!st_line)
	{
		free(st_line);
		st_line = NULL;
	}
	return (f_line);
}
// int	main(void)
// {
// 	int		fd;
// 	char	a;
// 	char	*next_line;

// 	a = 0;
// 	fd = open("example.txt",
// 			O_RDONLY);
// 	next_line = get_next_line(fd);
// 	printf("1-%s", next_line);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("2 %s", next_line);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("3 %s", next_line);
// 	// printf("%zd", read(fd, &a, 1));
// 	// write(1, &a, 1);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("4 %s", next_line);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("5 %s", next_line);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("6 %s", next_line);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("7 %s", next_line);
// 	free(next_line);
// 	next_line = get_next_line(fd);
// 	printf("8 %s", next_line);
// 	free(next_line);
// 	//next_line = get_next_line(fd);
// 	// printf("9 %s", next_line);
// 	// free(next_line);
// 	// next_line = get_next_line(fd);
// 	// printf("10 %s", next_line);
// 	// free(next_line);
// 	// next_line = get_next_line(fd);
// 	// printf("11 %s", next_line);
// 	// free(next_line);
// 	// next_line = get_next_line(fd);
// 	// printf("12 %s", next_line);
// 	// free(next_line);
// 	// next_line = get_next_line(fd);
// 	// printf("13 %s", next_line);
// 	// free(next_line);
// 	// next_line = get_next_line(fd);
// 	// printf("14 %s", next_line);
// 	// free(next_line);
// 	// 	close(fd);
// 	// 	return (0)
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 21:39:29 by elavrich          #+#    #+#             */
/*   Updated: 2025/09/21 20:06:32 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

int	ft_strlen_g(char *str)
{
	int	i;

	i = 0;
	while (str && str[i] != '\0')
	{
		i++;
	}
	return (i);
}

char	*ft_strjoin_g(char *s1, char *s2)
{
	int		i;
	int		j;
	char	*concat;

	concat = malloc(ft_strlen_g(s1) + ft_strlen_g(s2) + 1);
	if (!concat)
		return (free(s1), NULL);
	i = -1;
	while (s1[++i])
		concat[i] = s1[i];
	j = -1;
	while (s2[++j])
		concat[i + j] = s2[j];
	concat[i + j] = '\0';
	free(s1);
	return (concat);
}

int	ft_strchr_g(const char *s, char c)
{
	int	i;

	i = 0;
	while (s[i])
	{
		if (s[i] == c)
		{
			return (1);
		}
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   p_movement_1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/10 10:40:43 by javi              #+#    #+#             */
/*   Updated: 2025/11/10 21:13:29 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

int	validate_move(t_cub3D *cub3D, float new_x, float new_y)
{
	int	moved;

	moved = 0;
	if (!is_wall(cub3D->map, (int)new_x, (int)cub3D->player->pos_y))
	{
		cub3D->player->pos_x = new_x;
		moved = 1;
	}
	if (!is_wall(cub3D->map, (int)cub3D->player->pos_x, (int)new_y))
	{
		cub3D->player->pos_y = new_y;
		moved = 1;
	}
	return (moved);
}

static int	move_direction(t_cub3D *cub3D, float dir_x, float dir_y, float speed)
{
	return (validate_move(cub3D, 
		cub3D->player->pos_x + dir_x * speed,
		cub3D->player->pos_y + dir_y * speed));
}
/*
	if we want to keep this function like this, then I think p->move_y etc,
	should be restored to 0 if the move is not "valid"
*/
int	move_player(t_cub3D *cub3D) 
{
	int			moved;
	t_player	*p;

	moved = 0;
	p = cub3D->player;
	if (p->move_y == 1)
		moved += move_direction(cub3D, p->dir_x, p->dir_y, MOVESPEED);
	else if (p->move_y == -1)
		moved += move_direction(cub3D, -p->dir_x, -p->dir_y, MOVESPEED);
	if (p->move_x == -1)
		moved += move_direction(cub3D, p->dir_y, -p->dir_x, MOVESPEED);
	else if (p->move_x == 1)
		moved += move_direction(cub3D, -p->dir_y, p->dir_x, MOVESPEED);
	if (p->rotate != 0)
		moved += rotate_player(cub3D, p->rotate);
	return (moved);
}

int	rotate_player(t_cub3D *cub3D, float rotdir)
{
	t_player	*p;
	float		tmp_x;
	float		rotspeed;

	p = cub3D->player;
	rotspeed = ROTSPEED * rotdir;
	tmp_x = p->dir_x;
	p->dir_x = p->dir_x * cos(rotspeed) - p->dir_y * sin(rotspeed);
	p->dir_y = tmp_x * sin(rotspeed) + p->dir_y * cos(rotspeed);
	tmp_x = p->plane_x;
	p->plane_x = p->plane_x * cos(rotspeed) - p->plane_y * sin(rotspeed);
	p->plane_y = tmp_x * sin(rotspeed) + p->plane_y * cos(rotspeed);
	return (1);
}

/**
 * game_loop - Main game loop called by mlx_loop_hook
 * This function is called continuously by MLX
 * It checks for player input and re-renders if needed
 */
// int	game_loop(void *param) //Alex: this function is unused so far, and I think unnecessary. (I can explain why if needed)
// {
// 	t_cub3D	*cub3D;
// 	int		moved;

// 	cub3D = (t_cub3D *)param;
// 	// Check if player has any movement inputs
// 	if (cub3D->player->move_x != 0 || cub3D->player->move_y != 0 
// 		|| cub3D->player->rotate != 0)
// 	{
// 		// Process movement
// 		moved = move_player(cub3D);
// 		// Only re-render if player actually moved
// 		if (moved)
// 		{
// 			render_3d_view(cub3D);
// 		}
// 	}
// 	return (0);
//} 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/10 10:59:46 by javi              #+#    #+#             */
/*   Updated: 2025/11/12 19:37:44 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

void	debug_player_state(t_cub3D *cub3D, const char *context)
{
	if (!DEBUG_MODE)
		return;
	
	printf("\n=== PLAYER STATE: %s ===\n", context);
	printf("Position: (%.2f, %.2f)\n", 
		cub3D->player->pos_x, cub3D->player->pos_y);
	printf("Direction Vector: (%.2f, %.2f)\n", 
		cub3D->player->dir_x, cub3D->player->dir_y);
	printf("Camera Plane: (%.2f, %.2f)\n", 
		cub3D->player->plane_x, cub3D->player->plane_y);
	printf("Move Flags: move_x=%d, move_y=%d, rotate=%d\n",
		cub3D->player->move_x, cub3D->player->move_y, cub3D->player->rotate);
	printf("Has Moved: %d\n", cub3D->player->has_moved);
	printf("Facing: %c\n", cub3D->player->dir);
	printf("Angle (calculated): %.2f radians (%.1f degrees)\n",
		atan2(cub3D->player->dir_y, cub3D->player->dir_x),
		atan2(cub3D->player->dir_y, cub3D->player->dir_x) * 180 / PI);
	printf("========================\n\n");
}

void	debug_movement(t_cub3D *cub3D, const char *direction)
{
	if (!DEBUG_MOVEMENT)
		return;
	
	printf("[MOVEMENT] Attempting to move %s from (%.2f, %.2f)\n",
		direction, cub3D->player->pos_x, cub3D->player->pos_y);
}

void	debug_rotation(t_cub3D *cub3D, float rotdir)
{
	if (!DEBUG_ROTATION)
		return;
	
	printf("[ROTATION] Rotating %s by %.3f radians\n",
		rotdir > 0 ? "RIGHT" : "LEFT", ROTSPEED * rotdir);
	printf("  Before: dir=(%.2f, %.2f) plane=(%.2f, %.2f)\n",
		cub3D->player->dir_x, cub3D->player->dir_y,
		cub3D->player->plane_x, cub3D->player->plane_y);
}

void	debug_init_complete(t_cub3D *cub3D)
{
	if (!DEBUG_INIT)
		return;
	
	printf("\n╔════════════════════════════════════════╗\n");
	printf("║     INITIALIZATION COMPLETE            ║\n");
	printf("╚════════════════════════════════════════╝\n");
	printf("Map: %s\n", cub3D->map->file);
	printf("Map Dimensions: %d x %d\n", cub3D->map->width, cub3D->map->count);
	printf("Player Start: (%.2f, %.2f) facing %c\n",
		cub3D->player->pos_x, cub3D->player->pos_y, cub3D->player->dir);
	printf("Textures:\n");
	printf("  North: %s\n", cub3D->map->N_text.img ? "✓ Loaded" : "✗ Failed");
	printf("  South: %s\n", cub3D->map->S_text.img ? "✓ Loaded" : "✗ Failed");
	printf("  East:  %s\n", cub3D->map->E_text.img ? "✓ Loaded" : "✗ Failed");
	printf("  West:  %s\n", cub3D->map->W_text.img ? "✓ Loaded" : "✗ Failed");
	printf("Colors:\n");
	printf("  Floor: RGB(%d, %d, %d)\n",
		cub3D->map->f_red, cub3D->map->f_green, cub3D->map->f_blue);
	printf("  Ceiling: RGB(%d, %d, %d)\n",
		cub3D->map->c_red, cub3D->map->c_green, cub3D->map->c_blue);
	printf("════════════════════════════════════════\n\n");
}

void	debug_map_info(t_map *map)
{
	int	y;
	
	if (!DEBUG_INIT)
		return;
	
	printf("\n=== MAP CONTENT ===\n");
	y = 0;
	while (map->copy[y] && y < 20)  // Show first 20 lines max
	{
		printf("Line %2d: %s", y, map->copy[y]);
		if (!ft_strchr(map->copy[y], '\n'))
			printf("\n");
		y++;
	}
	if (map->copy[y])
		printf("... (%d more lines)\n", map->count - y);
	printf("===================\n\n");
}

static const char	*get_key_name(int keycode)
{
	if (keycode == W) return "W (Forward)";
	if (keycode == S) return "S (Backward)";
	if (keycode == A) return "A (Strafe Left)";
	if (keycode == D) return "D (Strafe Right)";
	if (keycode == XK_Left) return "Left Arrow (Rotate Left)";
	if (keycode == XK_Right) return "Right Arrow (Rotate Right)";
	if (keycode == XK_Escape) return "ESC (Quit)";
	return "Unknown Key";
}

void	debug_key_press(int keycode)
{
	if (!DEBUG_INPUT)
		return;
	
	printf("[INPUT] Key PRESSED: %s (code: %d)\n", get_key_name(keycode), keycode);
}

void	debug_key_release(int keycode)
{
	if (!DEBUG_INPUT)
		return;
	
	printf("[INPUT] Key RELEASED: %s (code: %d)\n", get_key_name(keycode), keycode);
}

void	debug_render_frame(int frame_count)
{
	static int last_print = 0;
	
	if (!DEBUG_RENDER)
		return;
	
	// Print every 60 frames (roughly once per second at 60fps)
	if (frame_count - last_print >= 60)
	{
		printf("[RENDER] Frame %d rendered\n", frame_count);
		last_print = frame_count;
	}
}

/**
 * debug_display_minimap - Display minimap in console for debugging
 */
void	debug_display_minimap(t_minimap *minimap)
{
	int	y;
	int	x;
	
	if (!DEBUG_MINIMAP)
		return;
	
	printf("\n=== MINIMAP DEBUG ===\n");
	printf("Size: %dx%d\n", minimap->size, minimap->size);
	printf("Tile size: %d pixels\n", minimap->tile_size);
	printf("Offset: (%d, %d)\n", minimap->offset_x, minimap->offset_y);
	printf("Map content:\n");
	
	y = 0;
	while (y < minimap->size && minimap->map[y])
	{
		x = 0;
		while (x < minimap->size)
		{
			if (minimap->map[y][x] == '\0')
				printf(" ");
			else
				printf("%c", minimap->map[y][x]);
			x++;
		}
		printf("\n");
		y++;
	}
	printf("====================\n\n");
}

void	debug_print_map_raw(t_map *map)
{
	int y = 0;
	
	printf("\n=== RAW MAP DEBUG ===\n");
	printf("Width: %d, Count: %d\n", map->width, map->count);
	while (y < map->count && map->copy[y])
	{
		printf("Line %2d (len=%zu): [", y, ft_strlen(map->copy[y]));
		for (int i = 0; map->copy[y][i]; i++)
		{
			if (map->copy[y][i] == '\n')
				printf("\\n");
			else if (map->copy[y][i] == ' ')
				printf("_");
			else
				printf("%c", map->copy[y][i]);
		}
		printf("]\n");
		y++;
	}
	printf("===================\n\n");
}

void	debug_player_spawn_simple(t_cub3D *cub3D)
{
	int player_x = (int)cub3D->player->pos_x;
	int player_y = (int)cub3D->player->pos_y;
	
	printf("\n🎮 PLAYER SPAWN:\n");
	printf("   Grid pos: [%d, %d]\n", player_x, player_y);
	printf("   Exact pos: (%.2f, %.2f)\n", cub3D->player->pos_x, cub3D->player->pos_y);
	printf("   File line: %d\n", player_y + cub3D->map->conf_c);
	printf("   Facing: %c (dir: %.2f, %.2f)\n", 
		cub3D->player->dir, cub3D->player->dir_x, cub3D->player->dir_y);
	printf("   Standing on: '%c'\n", get_map_char(cub3D->map, player_x, player_y));
	printf("\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/07 10:40:02 by javi              #+#    #+#             */
/*   Updated: 2025/11/12 00:00:34 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

int create_rgb(int r, int g, int b)
{
	// printf("r %d\n", r);
	// printf("g %d\n", g);
	// printf("b %d\n", b);
	return (r << 16 | g << 8 | b);
}

/**
 * is_wall - Check if a map position contains a wall
 * @map: The game map structure
 * @x: X coordinate in map grid
 * @y: Y coordinate in map grid
 * 
 * Returns: 1 if wall ('1'), 0 if empty space ('0' or player spawn)
 */
int is_wall(t_map *map, int x, int y)
{
	// Bounds check - outside map is considered a wall
	if (y < 0 || y >= map->count || x < 0)
		return (1);
	
	if (!map->copy[y] || x >= (int)ft_strlen(map->copy[y]))
		return (1);
	
	// '1' is a wall, everything else is walkable - Alex: I had the "is walkable" variable for this (in case we will have doors, for example.)
	return (map->copy[y][x] == '1');
}

/**
 * normalize_angle - Keep angle within 0 to 2π range
 * @angle: The angle to normalize
 * 
 * Returns: Normalized angle
 */
float normalize_angle(float angle)
{
	while (angle < 0)
		angle += 2 * PI;
	while (angle >= 2 * PI)
		angle -= 2 * PI;
	return (angle);
}
/**
 * cast_single_ray - Cast one ray and find where it hits a wall
 * @player: Player position and angle
 * @map: Game map
 * @ray_angle: Direction to cast this ray
 * 
 * This is the heart of raycasting. We step forward in small increments
 * along the ray direction until we hit a wall.
 * 
 * Returns: Ray structure with hit information
 */
t_ray cast_single_ray(t_player *player, t_map *map, float ray_angle)
{
	t_ray   ray;
	float   ray_x;          // Current ray position X
	float   ray_y;          // Current ray position Y
	float   ray_dir_x;      // Ray direction X component
	float   ray_dir_y;      // Ray direction Y component
	float   distance;       // Total distance traveled
	int     map_x;          // Current map grid X
	int     map_y;          // Current map grid Y
	int   prev_map_x;
	// Initialize ray starting at player position
	ray_x = player->pos_x;
	ray_y = player->pos_y;
	
	// Calculate ray direction vector from angle
	ray_dir_x = cos(ray_angle);
	ray_dir_y = sin(ray_angle);
	
	// Start with zero distance
	distance = 0;
	// Store initial grid position
	prev_map_x = (int)ray_x;
	while (distance < MAX_DEPTH)
	{
		// Advance ray
		ray_x += ray_dir_x * RAY_STEP;
		ray_y += ray_dir_y * RAY_STEP;
		distance += RAY_STEP;
		
		// Get current grid cell
		map_x = (int)ray_x;
		map_y = (int)ray_y;
		
		// Check if we hit a wall
		if (is_wall(map, map_x, map_y))
		{
			// Store hit information
			ray.distance = distance;
			ray.angle = ray_angle;
			ray.wall_x = ray_x;
			ray.wall_y = ray_y;
			// Determine if we hit a vertical or horizontal wall
			// This is used to shade walls differently for depth perception
			if (prev_map_x != map_x)
				ray.hit_vertical = 1;  // Crossed vertical grid line (hit E/W wall)
			else
				ray.hit_vertical = 0;   // Crossed horizontal grid line (hit N/S wall)
			return (ray);
		}
		prev_map_x = map_x;
	}
	// No wall found within max depth - return max distance
	ray.distance = MAX_DEPTH;
	ray.angle = ray_angle;
	ray.wall_x = ray_x;
	ray.wall_y = ray_y;
	ray.hit_vertical = 0;
	return (ray);
}

/**
 * calculate_wall_height - Calculate screen height of wall slice
 * @distance: Distance from player to wall
 * 
 * Closer walls appear taller on screen. Alex: I feel something is missing bc the width is fucked.
 * We use inverse proportion: height = constant / distance
 * 
 * Returns: Height in pixels
 */
int calculate_wall_height(float distance)
{
	int height;
	
	// Avoid division by zero
	if (distance < 0.01)
		distance = 0.01;
	
	// distance is in grid units 
	height = (int)(WIN_HEIGHT / distance);
	
	// Clamp to reasonable values
	if (height > WIN_HEIGHT * 3)
		height = WIN_HEIGHT * 3;
	
	return (height);
}

/**
 * get_wall_color - Determine color for wall based on direction
 * @ray: The ray that hit the wall
 * 
 * We shade vertical and horizontal walls differently to create
 * depth perception (like lighting from above).
 * 
 * Returns: RGB color integer
 */
int get_wall_color(t_ray ray)
{
	t_color color;
	
	if (ray.hit_vertical)
	{
		// Vertical walls (North/South) - Lighter shade
		color.r = 200;
		color.g = 50;
		color.b = 50;
	}
	else
	{
		// Horizontal walls (East/West) - Darker shade
		color.r = 150;
		color.g = 30;
		color.b = 30;
	}
	
	// Optional: Add distance-based darkening (fog effect)
	float fog = 1.0 - (ray.distance / MAX_DEPTH);
	if (fog < 0.3)
		fog = 0.3;  // Don't go completely black
	
	color.r *= fog;
	color.g *= fog;
	color.b *= fog;
	
	return (create_rgb(color.r, color.g, color.b));
}

/**
 * draw_vertical_line - Draw one vertical stripe of the wall
 * @cub3D: Main game structure
 * @x: Screen X coordinate (column)
 * @wall_height: Height of wall to draw
 * @color: Color of the wall
 * 
 * This draws one vertical slice of wall, centered on screen.
 */
void draw_vertical_line(t_cub3D *cub3D, int x, int wall_height, int color)
{
	int y;
	int start_y;
	int end_y;
	
	// Calculate where wall starts and ends on screen (centered vertically)
	start_y = (WIN_HEIGHT / 2) - (wall_height / 2);
	end_y = start_y + wall_height;
	
	// Clamp to screen bounds
	if (start_y < 0)
		start_y = 0;
	if (end_y > WIN_HEIGHT)
		end_y = WIN_HEIGHT;
	
	// Draw ceiling (above wall) 
	y = 0;
	while (y < start_y)
	{
		mlx_pixel_put(cub3D->mlx, cub3D->win, x, y,
			create_rgb(cub3D->map->c_red, cub3D->map->c_green, cub3D->map->c_blue));
		y++;
	}
	
	// Draw wall
	y = start_y;
	while (y < end_y)
	{
		mlx_pixel_put(cub3D->mlx, cub3D->win, x, y, color);
		y++;
	}
	
	// Draw floor (below wall)
	y = end_y;
	while (y < WIN_HEIGHT)
	{
		mlx_pixel_put(cub3D->mlx, cub3D->win, x, y,
			create_rgb(cub3D->map->f_red, cub3D->map->f_green, cub3D->map->f_blue));
		y++;
	}
}
#ifndef CUB3D
# define CUB3D

# include "libft/get_next_line/get_next_line.h"
# include "libft/printf/ft_printf.h"
# include "libft/src/libft.h"
# include "minilibx-linux/mlx.h"
# include "minilibx-linux/mlx_int.h"
# include <X11/Xlib.h>
# include <X11/keysym.h>
# include <math.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

# define PI 3.14159265
# define TILE_SIZE 30
# define PLAYER_HEIGHT 32

//Minimap vars
# define MMAP_PIXEL_SIZE 128
# define MMAP_VIEW_DIST 4
# define MMAP_COLOR_PLAYER 0x00FF00
# define MMAP_COLOR_WALL 0x808080
# define MMAP_COLOR_FLOOR 0xE6E6E6
# define MMAP_COLOR_SPACE 0x404040

# define MOVESPEED 0.1
# define ROTSPEED 0.05

//find the X11 equivalent later
# define S 115
# define D 100
# define W 119
# define A 97

# define ST 1
# define WT 2
# define ET 3
# define NT 4
# define F 5
# define C 6

# define F_L 7 //first and last row of map, for the walls check
# define MID 8 //middle rows, also for walls check

# define WIN_WIDTH 800  // Width of the game window
# define WIN_HEIGHT 600 // Height of the game window
# define FOV 0.66       // Field of view (radians) - Alex: fyi I tried to change it and there was no difference whatsoever. 
# define RAY_STEP 0.01  // How much we advance the ray each iteration
# define MAX_DEPTH 20.0 // Maximum distance a ray can travel

# define DEBUG_MODE 1
# define DEBUG_MOVEMENT 1
# define DEBUG_ROTATION 1
# define DEBUG_RENDER 1
# define DEBUG_MINIMAP 1
# define DEBUG_INIT 1
# define DEBUG_INPUT 1

typedef struct g_cub3D	t_cub3D;

typedef struct s_cub_img
{
	void				*img;
	char				*addr;
	int					bits_per_pixel;
	int					line_len;
	int					endian;
}						t_cub_img;

typedef struct s_minimap
{
	char				**map;
	t_cub_img			img;
	int					size;
	int					offset_x;
	int					offset_y;
	int					view_dist;
	int					tile_size;
}						t_minimap;

typedef struct s_color
{
	int r; // Red component (0-255)
	int g; // Green component (0-255)
	int b; // Blue component (0-255)
}						t_color;

typedef struct s_ray
{
	float angle;      // Direction angle of the ray
	float distance;   // Distance to wall hit
	int hit_vertical; // Did we hit a vertical wall? (for coloring)
	float wall_x;     // X coordinate where ray hit the wall
	float wall_y;     // Y coordinate where ray hit the wall
}						t_ray;

typedef struct g_player
{
	float pos_x;   // Player X position
	float pos_y;   // Player Y position
	float dir_x;   // Direction vector X
	float dir_y;   // Direction vector Y
	float plane_x; // Camera plane X
	float plane_y; // Camera plane Y
	char dir;      // Initial direction (N/S/E/W)
	int move_x;    // Strafe movement (-1, 0, 1)
	int move_y;    // Forward/back movement (-1, 0, 1)
	int rotate;    // Rotation (-1, 0, 1)
	int has_moved; // Movement flag
	float angle;   // Player angle (might not need this if using dir_x/dir_y)
	float speed;   // Movement speed
}						t_player;

typedef struct g_map
{
	char				*file;
	int					f_red;
	int					f_green;
	int					f_blue;
	int					c_red;
	int					c_green;
	int					c_blue;
	t_cub_img			N_text;
	t_cub_img			S_text;
	t_cub_img			E_text;
	t_cub_img			W_text;
	char				*texture;
	char				*player;
	int					walkable;
	int					count;
	int					width;
	char				**copy;
	int					conf_c;
	t_cub3D				*cub3D;
}						t_map;

typedef struct g_cub3D
{
	void				*mlx;
	void				*win;
	int					w_height;
	t_cub_img img; //drawing buffer
	int					w_width;
	t_map				*map;
	t_player			*player;

}						t_cub3D;

//error handling
int						arg_error(int argc, char **argv);
int						map_error(int fd);

//initializing & starting values
int						mlx_set(t_cub3D *Cub3D);
int						init_player(t_cub3D *Cub3D);
void					extract_color(char *line, int *colors);
void					render_3d_view(t_cub3D *cub3D);
int						create_rgb(int r, int g, int b);

//map
int						load_map(t_map *map);
void					set_textures_col(t_map *map, int op, char *path);
void					create_copy(t_map *map);
int						is_config_line(char *line);
void					set_colors(t_map *map, int op, char *line);
void					configs(t_map *map);
int						is_wall(t_map *map, int x, int y);
float					normalize_angle(float angle);
t_ray					cast_single_ray(t_player *player, t_map *map,
							float ray_angle);
int						calculate_wall_height(float distance);
int						get_wall_color(t_ray ray);
void					draw_vertical_line(t_cub3D *cub3D, int x,
							int wall_height, int color);
void					my_mlx_pixel_put(t_cub_img *img, int x, int y,
							int color);
t_cub_img				*get_wall_texture(t_map *map, t_ray ray);
void					render_minimap(t_cub3D *cub3D);
int						walls_check(t_map *map);

//minimap_1.c
int						get_minimap_offset(t_minimap *minimap, int mapsize,
							int pos);
int						is_valid_map_coord(int coord, int size);
char					*add_minimap_line(t_cub3D *cub3D, t_minimap *m, int y);
char					**generate_minimap(t_cub3D *cub3D, t_minimap *minimap);
void					draw_minimap_ray(t_minimap *m, t_player *p);

//minimap_2.c
void					set_minimap_tile_pixels(t_minimap *m, int x, int y,
							int color);
void					draw_minimap_tile(t_minimap *minimap, int x, int y);
void					set_minimap_border(t_minimap *minimap, int color);
void					debug_display_minimap(t_minimap *minimap);

//window actions
int						ft_key_press(int keycode, void *v);
int						ft_close(void *param);
int						ft_key_release(int keycode, void *v);
//player actions
int						validate_move(t_cub3D *cub3D, float new_x, float new_y);
int						move_player(t_cub3D *cub3D);
int						rotate_player(t_cub3D *cub3D, float rotdir);

//debug
void					debug_player_state(t_cub3D *cub3D, const char *context);
void					debug_movement(t_cub3D *cub3D, const char *direction);
void					debug_rotation(t_cub3D *cub3D, float rotdir);
void					debug_init_complete(t_cub3D *cub3D);
void					debug_map_info(t_map *map);
void					debug_key_press(int keycode);
void					debug_key_release(int keycode);
void					debug_render_frame(int frame_count);

//int						game_loop(void *param); //unused - see comment on function
char					*config_l(int fd);
int						iter_rows(t_map *map, int index, int iter, bool middle);
void					debug_print_map_raw(t_map *map);
char					get_map_char(t_map *map, int x, int y);
void					debug_player_spawn_simple(t_cub3D *cub3D);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 22:05:57 by elavrich          #+#    #+#             */
/*   Updated: 2025/11/12 18:32:58 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

// NO ./path_to_the_north_texture
// SO ./path_to_the_south_texture
// WE ./path_to_the_west_texture
// EA ./path_to_the_east_texture

//rgb(red, green, blue)
// F 220,100,0
// C 225,30,0

//floor & ceiling have color

//check configs and parse accordingly
//if configs missing -> error

//check map
//display textures as needed

static int	set_config(t_map *map, char *line)
{
	if (!ft_strncmp(line, "NO ", 3))
		set_textures_col(map, NT, line + 3);
	else if (!ft_strncmp(line, "SO ", 3))
		set_textures_col(map, ST, line + 3);
	else if (!ft_strncmp(line, "WE ", 3))
		set_textures_col(map, WT, line + 3);
	else if (!ft_strncmp(line, "EA ", 3))
		set_textures_col(map, ET, line + 3);
	else if (!ft_strncmp(line, "F ", 2))
		set_colors(map, F, line + 2);
	else if (!ft_strncmp(line, "C ", 2))
		set_colors(map, C, line + 2);
	return (1);
}

void	configs(t_map *map)
{
	int	y;

	y = 0;
	while (map->copy[y][0])
	{
		if (is_config_line(map->copy[y]) || map->copy[y][0] == '\n')
		{
			set_config(map, map->copy[y]);
			y++;
		}
		else
			break ;
	}
	map->conf_c = y;
}

void	create_copy(t_map *map)
{
	int	fd;
	int	y;
	int len;

	len = 0;
	y = 0;
	map->width = 0; //new, initialize width for mmap
	fd = open(map->file, O_RDONLY);
	if (fd < 0)
		return (free(map->copy));
	while (y < map->count)
	{
		map->copy[y] = get_next_line(fd);
		if (!map->copy[y])
		{
			while (--y >= 0)
				free(map->copy[y]);
			free(map->copy);
			map->copy = NULL;
			if(close(fd))	
				perror("close");
			return ;
		}
		len = ft_strlen(map->copy[y]);
		if (len > 0 && map->copy[y][len - 1] == '\n')
			len--;
		if (len > map->width)
			map->width = len;
		y++;
	}
	map->copy[y++] = NULL;
	if(close(fd))	
		perror("close");
}

int	walls_check(t_map *map)
{
	int	rows;
	int	middle;

	rows = map->conf_c;
	if (!iter_rows(map, rows, 0, false))
		return (0);
	while (map->copy[rows])
		rows++;
	if (!iter_rows(map, rows - 1, 0, false))
		return (0);
	middle = map->conf_c + 1;
	while (middle < rows - 1)
	{
		if (!iter_rows(map, middle, 0, true))
			return (0);
		middle++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   win_actions.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: elavrich <elavrich@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 18:24:25 by elavrich          #+#    #+#             */
/*   Updated: 2025/11/10 20:40:12 by elavrich         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

int	ft_close(void *param)
{
	t_cub3D	*cub3D;

	cub3D = (t_cub3D *)param;
	
	// Destroy textures if they were loaded
	if (cub3D->map->N_text.img)
		mlx_destroy_image(cub3D->mlx, cub3D->map->N_text.img);
	if (cub3D->map->S_text.img)
		mlx_destroy_image(cub3D->mlx, cub3D->map->S_text.img);
	if (cub3D->map->E_text.img)
		mlx_destroy_image(cub3D->mlx, cub3D->map->E_text.img);
	if (cub3D->map->W_text.img)
		mlx_destroy_image(cub3D->mlx, cub3D->map->W_text.img);
	
	// Destroy main image buffer
	if (cub3D->img.img)
		mlx_destroy_image(cub3D->mlx, cub3D->img.img);
	
	// Destroy window
	if (cub3D->win)
		mlx_destroy_window(cub3D->mlx, cub3D->win);
	
	// Free map data
	if (cub3D->map && cub3D->map->copy)
	{
		int i = 0;
		while (cub3D->map->copy[i])
		{
			free(cub3D->map->copy[i]);
			i++;
		}
		free(cub3D->map->copy);
	}
	if (cub3D->map)
		free(cub3D->map);
	
	// Destroy display (this also frees mlx pointer)
	if (cub3D->mlx)
		mlx_destroy_display(cub3D->mlx);
	
	exit(0);
	return (0);
}

static int	handle_movement_keys(int keycode, t_player *p)
{
	if(keycode != W && keycode != S && keycode != A && keycode != D && keycode != XK_Left && keycode != XK_Right)
		return 0;
	if (keycode == W)
		p->move_y = 1;
	else if (keycode == S)
		p->move_y = -1;
	else if (keycode == A)
		p->move_x = -1;
	else if (keycode == D)
		p->move_x = 1;
	else if (keycode == XK_Left)
		p->rotate = -1;
	else if (keycode == XK_Right)
		p->rotate = 1;
	return 1;
}


int	ft_key_press(int keycode, void *v)
{
	t_cub3D	*cub3D;

	cub3D = v;
	if (keycode == XK_Escape)
		ft_close(cub3D);
	if(handle_movement_keys(keycode, cub3D->player))
	{
		if(move_player(cub3D))
			render_3d_view(cub3D);
	}
	return (0);
}

static void	release_movement_keys(int keycode, t_player *p)
{
	if ((keycode == W && p->move_y == 1) || (keycode == S && p->move_y == -1))
		p->move_y = 0;
	if ((keycode == A && p->move_x == -1) || (keycode == D && p->move_x == 1))
		p->move_x = 0;
}

int	ft_key_release(int keycode, void *v)
{
	t_cub3D	*cub3D;

	cub3D = v;
	release_movement_keys(keycode, cub3D->player);
	if ((keycode == XK_Left && cub3D->player->rotate == -1) ||
		(keycode == XK_Right && cub3D->player->rotate == 1))
		cub3D->player->rotate = 0;
	return (0);
}
#include "cub3D.h"

//we can add a check for missing configs and colors 
int	is_config_line(char *line)
{
	while (*line == ' ' || *line == '\t')
		line++;
	return (
		ft_strncmp(line, "NO ", 3) == 0 ||
		ft_strncmp(line, "SO ", 3) == 0 ||
		ft_strncmp(line, "WE ", 3) == 0 ||
		ft_strncmp(line, "EA ", 3) == 0 ||
		ft_strncmp(line, "F ", 2) == 0 ||
		ft_strncmp(line, "C ", 2) == 0);
}

static int	valid_map_char(char c)
{
	return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W'
		|| c == ' ' || c == '\n' || c == '\t');
}

int	map_error(int fd)
{
	char	*line;
	int		i;
	int		error;

	error = 0;
	line = config_l(fd);
	while ((line = get_next_line(fd)))
	{
		i = 0;
		while (line[i])
		{
			if (!valid_map_char(line[i]))
				error = 1;
			i++;
		}
		free(line);
	}
	if(close(fd))
		perror("close");
	if (error)
		return (printf("wrong char in file\n"), 1);
	return (0);
}

int	arg_error(int argc, char **argv)
{
	int		fd;
	char	*point;

	if (argc != 2)
		return (printf("wrong number of args\n"), 1);
	point = ft_strrchr(argv[1], '.');
	if (!point || ft_strncmp(point, ".cub", 4) != 0)
		return (printf("wrong extension\n"), 1);
	fd = open(argv[1], O_RDONLY);
	if (fd < 0)
		return (printf("could not open file\n"), 1);
	if (map_error(fd))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minimap_2.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/09 08:50:28 by javi              #+#    #+#             */
/*   Updated: 2025/11/12 18:36:13 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

/**
 * get_minimap_offset - Calculate offset to center minimap on player
 * If player is near edge, shift minimap so edges don't go off screen
 */
int	get_minimap_offset(t_minimap *minimap, int mapsize, int pos)
{
	if (pos > minimap->view_dist && mapsize - pos > minimap->view_dist + 1)
		return (pos - minimap->view_dist);
	if (pos > minimap->view_dist && mapsize - pos <= minimap->view_dist + 1)
		return (mapsize - minimap->size);
	return (0);
}

/**
 * is_valid_map_coord - Check if coordinate is within map bounds
 */
int	is_valid_map_coord(int coord, int size)
{
	if (coord < size)
		return (1);
	return (0);
}

/**
 * add_minimap_line - Create one line of the minimap
 * P = player, 1 = wall, 0 = floor, \0 = void/out of bounds
 */
char	*add_minimap_line(t_cub3D *cub3D, t_minimap *m, int y)
{
	char	*line;
	int		x;
	int		player_x;
	int		player_y;
	char	map_char;

	line = malloc(sizeof(char) * (m->size + 1));
	if (!line)
		return (NULL);	
	
	player_x = (int)cub3D->player->pos_x;
	player_y = (int)cub3D->player->pos_y;
	
	x = 0;
	while (x < m->size)
	{
		if (player_x == (x + m->offset_x) && player_y == (y + m->offset_y))
			line[x] = 'P';
		else
		{
			map_char = get_map_char(cub3D->map, x + m->offset_x, y + m->offset_y);
			if (map_char == '1')
				line[x] = '1';
			else if (map_char == '0')
				line[x] = '0';
			else
				line[x] = ' ';  // Use space instead of '\0' for out of bounds
		}
		x++;
	}
	line[m->size] = '\0';
	return (line);
}
/*
 * generate_minimap - Create full minimap char array centered on player
 */
 
char	**generate_minimap(t_cub3D *cub3D, t_minimap *minimap)
{
	char	**mmap;
	int		y;

	mmap = malloc(sizeof(char *) * (minimap->size + 1));
	if (!mmap)
		return (NULL);	
	y = 0;
	while (y < minimap->size)
	{
		mmap[y] = add_minimap_line(cub3D, minimap, y);
		if (!mmap[y])
		{
			while (--y >= 0)
				free(mmap[y]);
			free(mmap);
			return (NULL);
		}
		y++;
	}
	mmap[minimap->size] = NULL;
	return (mmap);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: javi <javi@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/22 18:52:05 by elavrich          #+#    #+#             */
/*   Updated: 2025/11/12 18:33:42 by javi             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3D.h"

void		extract_color(char *line, int *colors)
{
	int	i;
	int	count;
	int	val;

	i = 0;
	count = 0;
	val = 0;
	while (line[i] && count < 3)
	{
		while (line[i] == ' ' || line[i] == '\t')
			i++;
		val = 0;
		while (line[i] >= '0' && line[i] <= '9')
		{
			val = val * 10 + (line[i] - '0');
			i++;
		}
		colors[count++] = val;
		if (line[i] == ',')
		{
			i++;
		}
	}
}

char	*config_l(int fd)
{
	char	*line;

	while ((line = get_next_line(fd)))
	{
		if (is_config_line(line) || line[0] == '\n')
			free(line);
		else
		{
			free(line);
			break ;
		}
	}
	return (line);
}

//function unused for now
// void sizem(t_cub3D *Cub3D) //size of map
// {
// 	int rows = Cub3D->map->conf_c;
// 	int columns = 0;
// 	while (Cub3D->map->copy[rows] != NULL)
// 		rows++;
// 	if (rows > 0)
// 		columns = ft_strlen(Cub3D->map->copy[Cub3D->map->conf_c]) - 1;
// 	else
// 		columns = 0;
// 	Cub3D->w_height = rows * TILE_SIZE;
// 	Cub3D->w_width = columns * TILE_SIZE;
// }
// as we allow jagged edges,this will need to be changed,if we need the function.

int	iter_rows(t_map *map, int index, int iter, bool middle)
{
	int	j;

	if (!middle)
	{
		while (map->copy[index][iter] == ' ')
			iter++;
		while (map->copy[index][iter] != '\n' && map->copy[index][iter] != '\0')
		{
			if (map->copy[index][iter] != '1' && map->copy[index][iter] != ' ') //only 1 and spaces are allowed in the first and last row
				return (0);
			iter++;
		}
		return (1);
	}
	while (map->copy[index][iter] == ' ') //skip spaces
		iter++;
	if (map->copy[index][iter] != '1') //first wall of middle rows
		return (0);
	j = ft_strlen(map->copy[index]) - 1; //find end of row
	while (map->copy[index][j] == ' ' || map->copy[index][j] == '\n') //skip spaces or newlines
		j--;
	if (map->copy[index][j] != '1') //first non-space char has to be a 1 
		return (0);
	return (1);
}
char	get_map_char(t_map *map, int x, int y)
{
	int	len;
	
	if (y < 0 || y >= map->count || x < 0)
		return ('\0');
	if (!map->copy[y])
		return ('\0');
	
	len = ft_strlen(map->copy[y]);
	if (len > 0 && map->copy[y][len - 1] == '\n')
		len--;
	
	if (x >= len)
		return ('\0');
	
	return (map->copy[y][x]);
}
